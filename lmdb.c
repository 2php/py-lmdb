/* Generated by Cython 0.18 on Tue Feb  5 00:37:45 2013 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02040000
    #error Cython requires Python 2.4+.
#else
#include <stddef.h> /* For offsetof */
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PY_FORMAT_SIZE_T ""
  #define CYTHON_FORMAT_SSIZE_T ""
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
                                (PyErr_Format(PyExc_TypeError, \
                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
                                 (PyObject*)0))
  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
                                  !PyComplex_Check(o))
  #define PyIndex_Check __Pyx_PyIndex_Check
  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
  #define __PYX_BUILD_PY_SSIZE_T "i"
#else
  #define __PYX_BUILD_PY_SSIZE_T "n"
  #define CYTHON_FORMAT_SSIZE_T "z"
  #define __Pyx_PyIndex_Check PyIndex_Check
#endif
#if PY_VERSION_HEX < 0x02060000
  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
  #define PyVarObject_HEAD_INIT(type, size) \
          PyObject_HEAD_INIT(type) size,
  #define PyType_Modified(t)
  typedef struct {
     void *buf;
     PyObject *obj;
     Py_ssize_t len;
     Py_ssize_t itemsize;
     int readonly;
     int ndim;
     char *format;
     Py_ssize_t *shape;
     Py_ssize_t *strides;
     Py_ssize_t *suboffsets;
     void *internal;
  } Py_buffer;
  #define PyBUF_SIMPLE 0
  #define PyBUF_WRITABLE 0x0001
  #define PyBUF_FORMAT 0x0004
  #define PyBUF_ND 0x0008
  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
#endif
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PyBytesObject                PyStringObject
  #define PyBytes_Type                 PyString_Type
  #define PyBytes_Check                PyString_Check
  #define PyBytes_CheckExact           PyString_CheckExact
  #define PyBytes_FromString           PyString_FromString
  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
  #define PyBytes_FromFormat           PyString_FromFormat
  #define PyBytes_DecodeEscape         PyString_DecodeEscape
  #define PyBytes_AsString             PyString_AsString
  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
  #define PyBytes_Size                 PyString_Size
  #define PyBytes_AS_STRING            PyString_AS_STRING
  #define PyBytes_GET_SIZE             PyString_GET_SIZE
  #define PyBytes_Repr                 PyString_Repr
  #define PyBytes_Concat               PyString_Concat
  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_VERSION_HEX < 0x03020000
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
#else
  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
#else
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_NAMESTR(n) ((char *)(n))
  #define __Pyx_DOCSTR(n)  ((char *)(n))
#else
  #define __Pyx_NAMESTR(n) (n)
  #define __Pyx_DOCSTR(n)  (n)
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE__lmdb
#define __PYX_HAVE_API__lmdb
#include "sys/stat.h"
#include "lmdb.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const long n; const char* encoding; const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/

#define __Pyx_PyBytes_FromUString(s) PyBytes_FromString((char*)s)
#define __Pyx_PyBytes_AsUString(s)   ((unsigned char*) PyBytes_AsString(s))
#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))


#ifdef __GNUC__
  /* Test for GCC > 2.95 */
  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
    #define likely(x)   __builtin_expect(!!(x), 1)
    #define unlikely(x) __builtin_expect(!!(x), 0)
  #else /* __GNUC__ > 2 ... */
    #define likely(x)   (x)
    #define unlikely(x) (x)
  #endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "lmdb.pyx",
};

/*--- Type declarations ---*/
struct __pyx_obj_4lmdb_Cursor;
struct __pyx_obj_4lmdb_Database;
struct __pyx_obj_4lmdb_Environment;
struct __pyx_obj_4lmdb_Transaction;

/* "lmdb.pyx":546
 * 
 * 
 * cdef class Cursor:             # <<<<<<<<<<<<<<
 *     """
 *     Structure for navigating through a database.
 */
struct __pyx_obj_4lmdb_Cursor {
  PyObject_HEAD
  struct __pyx_vtabstruct_4lmdb_Cursor *__pyx_vtab;
  struct __pyx_obj_4lmdb_Database *db;
  struct __pyx_obj_4lmdb_Transaction *txn;
  MDB_cursor *cursor_;
  struct MDB_val key_;
  struct MDB_val val_;
  int do_keys_;
  int do_values_;
};


/* "lmdb.pyx":386
 * 
 * 
 * cdef class Database:             # <<<<<<<<<<<<<<
 *     """
 *     Handle for an individual database in the DB environment.
 */
struct __pyx_obj_4lmdb_Database {
  PyObject_HEAD
  struct __pyx_vtabstruct_4lmdb_Database *__pyx_vtab;
  struct __pyx_obj_4lmdb_Transaction *txn;
  MDB_dbi dbi_;
  int dropped;
};


/* "lmdb.pyx":175
 * 
 * 
 * cdef class Environment:             # <<<<<<<<<<<<<<
 *     """
 *     Structure for a database environment.
 */
struct __pyx_obj_4lmdb_Environment {
  PyObject_HEAD
  MDB_env *env_;
};


/* "lmdb.pyx":314
 * 
 * 
 * cdef class Transaction:             # <<<<<<<<<<<<<<
 *     """
 *     A transaction handle.
 */
struct __pyx_obj_4lmdb_Transaction {
  PyObject_HEAD
  struct __pyx_vtabstruct_4lmdb_Transaction *__pyx_vtab;
  struct __pyx_obj_4lmdb_Environment *env;
  MDB_txn *txn_;
  int running;
  int readonly;
};



struct __pyx_vtabstruct_4lmdb_Transaction {
  PyObject *(*_throw)(struct __pyx_obj_4lmdb_Transaction *);
};
static struct __pyx_vtabstruct_4lmdb_Transaction *__pyx_vtabptr_4lmdb_Transaction;


/* "lmdb.pyx":546
 * 
 * 
 * cdef class Cursor:             # <<<<<<<<<<<<<<
 *     """
 *     Structure for navigating through a database.
 */

struct __pyx_vtabstruct_4lmdb_Cursor {
  PyObject *(*_throw_stop)(struct __pyx_obj_4lmdb_Cursor *, char const *, int, int __pyx_skip_dispatch);
  PyObject *(*_cursor_get)(struct __pyx_obj_4lmdb_Cursor *, MDB_cursor_op, int __pyx_skip_dispatch);
  PyObject *(*_itervalue)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch);
  PyObject *(*first)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch);
  PyObject *(*last)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch);
  PyObject *(*prev)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch);
  PyObject *(*next)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch);
  PyObject *(*delete)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_4lmdb_Cursor *__pyx_vtabptr_4lmdb_Cursor;


/* "lmdb.pyx":386
 * 
 * 
 * cdef class Database:             # <<<<<<<<<<<<<<
 *     """
 *     Handle for an individual database in the DB environment.
 */

struct __pyx_vtabstruct_4lmdb_Database {
  PyObject *(*_throw)(struct __pyx_obj_4lmdb_Database *);
};
static struct __pyx_vtabstruct_4lmdb_Database *__pyx_vtabptr_4lmdb_Database;
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          if (acquire_gil) { \
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
              PyGILState_Release(__pyx_gilstate_save); \
          } else { \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext() \
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif /* CYTHON_REFNANNY */
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/

static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
    const char* function_name); /*proto*/

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed); /*proto*/

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/

static PyObject *__Pyx_FindPy2Metaclass(PyObject *bases); /*proto*/

static PyObject *__Pyx_CreateClass(PyObject *bases, PyObject *dict, PyObject *name,
                                   PyObject *qualname, PyObject *modname); /*proto*/

static CYTHON_INLINE mode_t __Pyx_PyInt_from_py_mode_t(PyObject *);

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);

static int __Pyx_check_binary_version(void);

static int __Pyx_SetVtable(PyObject *dict, void *vtable); /*proto*/

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/


/* Module declarations from 'lmdb' */
static PyTypeObject *__pyx_ptype_4lmdb_Environment = 0;
static PyTypeObject *__pyx_ptype_4lmdb_Transaction = 0;
static PyTypeObject *__pyx_ptype_4lmdb_Database = 0;
static PyTypeObject *__pyx_ptype_4lmdb_Cursor = 0;
static PyObject *__pyx_f_4lmdb__throw(char const *, int); /*proto*/
#define __Pyx_MODULE_NAME "lmdb"
int __pyx_module_is_main_lmdb = 0;

/* Implementation of 'lmdb' */
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_StopIteration;
static int __pyx_pf_4lmdb_11Environment___init__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self, char const *__pyx_v_path, size_t __pyx_v_map_size, PyObject *__pyx_v_subdir, PyObject *__pyx_v_readonly, PyObject *__pyx_v_metasync, PyObject *__pyx_v_sync, PyObject *__pyx_v_map_async, mode_t __pyx_v_mode, PyObject *__pyx_v_create, int __pyx_v_max_readers, int __pyx_v_max_dbs); /* proto */
static void __pyx_pf_4lmdb_11Environment_2__dealloc__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_11Environment_4path___get__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_11Environment_11max_readers___get__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_11Environment_4sync(struct __pyx_obj_4lmdb_Environment *__pyx_v_self, PyObject *__pyx_v_force); /* proto */
static PyObject *__pyx_pf_4lmdb_11Environment_6stat(struct __pyx_obj_4lmdb_Environment *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_11Environment_8transaction(struct __pyx_obj_4lmdb_Environment *__pyx_v_self, PyObject *__pyx_v_kwargs); /* proto */
static int __pyx_pf_4lmdb_11Transaction___init__(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self, struct __pyx_obj_4lmdb_Environment *__pyx_v_env, struct __pyx_obj_4lmdb_Transaction *__pyx_v_parent, PyObject *__pyx_v_readonly); /* proto */
static void __pyx_pf_4lmdb_11Transaction_2__dealloc__(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_11Transaction_4db(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_4lmdb_11Transaction_6commit(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_11Transaction_8abort(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self); /* proto */
static int __pyx_pf_4lmdb_8Database___init__(struct __pyx_obj_4lmdb_Database *__pyx_v_self, struct __pyx_obj_4lmdb_Transaction *__pyx_v_txn, PyObject *__pyx_v_name, PyObject *__pyx_v_reverse_key, PyObject *__pyx_v_dupsort, PyObject *__pyx_v_create); /* proto */
static void __pyx_pf_4lmdb_8Database_2__dealloc__(struct __pyx_obj_4lmdb_Database *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_8Database_4drop(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_delete); /* proto */
static PyObject *__pyx_pf_4lmdb_8Database_6get(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_default); /* proto */
static PyObject *__pyx_pf_4lmdb_8Database_8put(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_value, PyObject *__pyx_v_dupdata, PyObject *__pyx_v_overwrite, PyObject *__pyx_v_append); /* proto */
static PyObject *__pyx_pf_4lmdb_8Database_10delete(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_4lmdb_8Database_12cursor(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_kwargs); /* proto */
static int __pyx_pf_4lmdb_6Cursor___init__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, struct __pyx_obj_4lmdb_Database *__pyx_v_db, PyObject *__pyx_v_keys, PyObject *__pyx_v_values); /* proto */
static void __pyx_pf_4lmdb_6Cursor_2__dealloc__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_4_throw_stop(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, char const *__pyx_v_what, int __pyx_v_rc); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_6_cursor_get(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, MDB_cursor_op __pyx_v_op); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_3key___get__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_5value___get__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_8_itervalue(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_10__iter__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_12first(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_14last(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_16prev(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_18next(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_20__next__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_22delete(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_4lmdb_6Cursor_5count___get__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self); /* proto */
static char __pyx_k_1[] = ": ";
static char __pyx_k_8[] = "Creating environment";
static char __pyx_k_9[] = "Setting map size";
static char __pyx_k_10[] = "Setting max readers";
static char __pyx_k_11[] = "Setting max DBs";
static char __pyx_k_13[] = "Getting environment statistics";
static char __pyx_k_14[] = "transaction already aborted or committed";
static char __pyx_k_17[] = "Beginning read-only transaction";
static char __pyx_k_18[] = "Beginning write transaction";
static char __pyx_k_19[] = "Committing transaction";
static char __pyx_k_23[] = "Opening database";
static char __pyx_k_24[] = "database was dropped.";
static char __pyx_k_27[] = "Getting key";
static char __pyx_k_31[] = "Setting key";
static char __pyx_k_32[] = "Deleting key";
static char __pyx_k_35[] = "Creating cursor";
static char __pyx_k_36[] = "Advancing cursor";
static char __pyx_k_37[] = "Deleting current key";
static char __pyx_k_38[] = "Getting duplicate count";
static char __pyx_k_39[] = "Directory path or file name prefix where this environment is\n        stored.";
static char __pyx_k_40[] = "Maximum number of client threads that may read this environment\n        simultaneously.";
static char __pyx_k_41[] = "The current key. Raises an exception if the cursor is invalid.";
static char __pyx_k_42[] = "Returns the current value. Raises an exception if the cursor is\n        invalid.";
static char __pyx_k_43[] = "Count of duplicates for the current key. Raises an exception if the\n        cursor is invalid.";
static char __pyx_k_44[] = "Raised when any MDB error occurs.";
static char __pyx_k__db[] = "db";
static char __pyx_k__os[] = "os";
static char __pyx_k__rc[] = "rc";
static char __pyx_k__env[] = "env";
static char __pyx_k__key[] = "key";
static char __pyx_k__txn[] = "txn";
static char __pyx_k__keys[] = "keys";
static char __pyx_k__last[] = "last";
static char __pyx_k__lmdb[] = "lmdb";
static char __pyx_k__mode[] = "mode";
static char __pyx_k__name[] = "name";
static char __pyx_k__next[] = "next";
static char __pyx_k__path[] = "path";
static char __pyx_k__prev[] = "prev";
static char __pyx_k__sync[] = "sync";
static char __pyx_k__what[] = "what";
static char __pyx_k__Error[] = "Error";
static char __pyx_k__depth[] = "depth";
static char __pyx_k__first[] = "first";
static char __pyx_k__force[] = "force";
static char __pyx_k__mkdir[] = "mkdir";
static char __pyx_k__psize[] = "psize";
static char __pyx_k__value[] = "value";
static char __pyx_k__append[] = "append";
static char __pyx_k__create[] = "create";
static char __pyx_k__delete[] = "delete";
static char __pyx_k__exists[] = "exists";
static char __pyx_k__parent[] = "parent";
static char __pyx_k__subdir[] = "subdir";
static char __pyx_k__values[] = "values";
static char __pyx_k__default[] = "default";
static char __pyx_k__dupdata[] = "dupdata";
static char __pyx_k__dupsort[] = "dupsort";
static char __pyx_k__entries[] = "entries";
static char __pyx_k__max_dbs[] = "max_dbs";
static char __pyx_k__Flushing[] = "Flushing";
static char __pyx_k____main__[] = "__main__";
static char __pyx_k____test__[] = "__test__";
static char __pyx_k__map_size[] = "map_size";
static char __pyx_k__metasync[] = "metasync";
static char __pyx_k__readonly[] = "readonly";
static char __pyx_k__warnings[] = "warnings";
static char __pyx_k__Exception[] = "Exception";
static char __pyx_k__map_async[] = "map_async";
static char __pyx_k__overwrite[] = "overwrite";
static char __pyx_k___itervalue[] = "_itervalue";
static char __pyx_k__leaf_pages[] = "leaf_pages";
static char __pyx_k___cursor_get[] = "_cursor_get";
static char __pyx_k___throw_stop[] = "_throw_stop";
static char __pyx_k__max_readers[] = "max_readers";
static char __pyx_k__reverse_key[] = "reverse_key";
static char __pyx_k__branch_pages[] = "branch_pages";
static char __pyx_k__StopIteration[] = "StopIteration";
static char __pyx_k__overflow_pages[] = "overflow_pages";
static PyObject *__pyx_kp_s_1;
static PyObject *__pyx_kp_s_14;
static PyObject *__pyx_kp_s_24;
static PyObject *__pyx_kp_s_44;
static PyObject *__pyx_n_s__Error;
static PyObject *__pyx_n_s__Exception;
static PyObject *__pyx_n_s__StopIteration;
static PyObject *__pyx_n_s____main__;
static PyObject *__pyx_n_s____test__;
static PyObject *__pyx_n_s___cursor_get;
static PyObject *__pyx_n_s___itervalue;
static PyObject *__pyx_n_s___throw_stop;
static PyObject *__pyx_n_s__append;
static PyObject *__pyx_n_s__branch_pages;
static PyObject *__pyx_n_s__create;
static PyObject *__pyx_n_s__db;
static PyObject *__pyx_n_s__default;
static PyObject *__pyx_n_s__delete;
static PyObject *__pyx_n_s__depth;
static PyObject *__pyx_n_s__dupdata;
static PyObject *__pyx_n_s__dupsort;
static PyObject *__pyx_n_s__entries;
static PyObject *__pyx_n_s__env;
static PyObject *__pyx_n_s__exists;
static PyObject *__pyx_n_s__first;
static PyObject *__pyx_n_s__force;
static PyObject *__pyx_n_s__key;
static PyObject *__pyx_n_s__keys;
static PyObject *__pyx_n_s__last;
static PyObject *__pyx_n_s__leaf_pages;
static PyObject *__pyx_n_s__lmdb;
static PyObject *__pyx_n_s__map_async;
static PyObject *__pyx_n_s__map_size;
static PyObject *__pyx_n_s__max_dbs;
static PyObject *__pyx_n_s__max_readers;
static PyObject *__pyx_n_s__metasync;
static PyObject *__pyx_n_s__mkdir;
static PyObject *__pyx_n_s__mode;
static PyObject *__pyx_n_s__name;
static PyObject *__pyx_n_s__next;
static PyObject *__pyx_n_s__os;
static PyObject *__pyx_n_s__overflow_pages;
static PyObject *__pyx_n_s__overwrite;
static PyObject *__pyx_n_s__parent;
static PyObject *__pyx_n_s__path;
static PyObject *__pyx_n_s__prev;
static PyObject *__pyx_n_s__psize;
static PyObject *__pyx_n_s__rc;
static PyObject *__pyx_n_s__readonly;
static PyObject *__pyx_n_s__reverse_key;
static PyObject *__pyx_n_s__subdir;
static PyObject *__pyx_n_s__sync;
static PyObject *__pyx_n_s__txn;
static PyObject *__pyx_n_s__value;
static PyObject *__pyx_n_s__values;
static PyObject *__pyx_n_s__warnings;
static PyObject *__pyx_n_s__what;
static PyObject *__pyx_int_0;
static PyObject *__pyx_k_2;
static PyObject *__pyx_k_3;
static PyObject *__pyx_k_4;
static PyObject *__pyx_k_5;
static PyObject *__pyx_k_6;
static PyObject *__pyx_k_7;
static PyObject *__pyx_k_12;
static PyObject *__pyx_k_16;
static PyObject *__pyx_k_20;
static PyObject *__pyx_k_21;
static PyObject *__pyx_k_22;
static PyObject *__pyx_k_26;
static PyObject *__pyx_k_28;
static PyObject *__pyx_k_29;
static PyObject *__pyx_k_30;
static PyObject *__pyx_k_33;
static PyObject *__pyx_k_34;
static PyObject *__pyx_k_tuple_15;
static PyObject *__pyx_k_tuple_25;

/* "lmdb.pyx":170
 *     """Raised when any MDB error occurs."""
 * 
 * cdef _throw(const char *what, int rc):             # <<<<<<<<<<<<<<
 *     if rc:
 *         raise Error(what + ": " + mdb_strerror(rc))
 */

static PyObject *__pyx_f_4lmdb__throw(char const *__pyx_v_what, int __pyx_v_rc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_throw", 0);

  /* "lmdb.pyx":171
 * 
 * cdef _throw(const char *what, int rc):
 *     if rc:             # <<<<<<<<<<<<<<
 *         raise Error(what + ": " + mdb_strerror(rc))
 * 
 */
  if (__pyx_v_rc) {

    /* "lmdb.pyx":172
 * cdef _throw(const char *what, int rc):
 *     if rc:
 *         raise Error(what + ": " + mdb_strerror(rc))             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__Error); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PyBytes_FromString(__pyx_v_what); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __pyx_t_3 = PyNumber_Add(((PyObject *)__pyx_t_2), ((PyObject *)__pyx_kp_s_1)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __pyx_t_2 = PyBytes_FromString(mdb_strerror(__pyx_v_rc)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __pyx_t_4 = PyNumber_Add(__pyx_t_3, ((PyObject *)__pyx_t_2)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("lmdb._throw", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static int __pyx_pw_4lmdb_11Environment_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_11Environment___init__[] = "\n        Environment(path, map_size=(64Mb), subdir=True, readonly=False,\n                    metasync=True, sync=True, mode=0644, create=True,\n                    max_readers=126, max_dbs=0)\n\n        Create and open an environment.\n\n            path: Location of directory (if subdir=True) or file prefix to\n                store the database.\n            map_size: Maximum size database may grow to; used to size the\n                memory mapping. If database grows larger than map_size, exception\n                will be raised and Environment must be recreated. On 64-bit\n                there is no penalty for making this huge (say 1TB). Must be\n                <2GB on 32-bit.\n            subdir: If True, `path` refers to a subdirectory to store the data\n                and lock files within, otherwise it refers to a filename prefix.\n            readonly: If True, disallow any write operations. Note the lock\n                file is still modified.\n            metasync: If False, never explicitly flush metadata pages to disk.\n                OS will flush at its disgression, or user can flush with\n                Environment.sync().\n            sync: If False, never explicitly fluh data pages to disk. OS will\n                flush at its disgression, or user can flush with\n                Environment.sync(). This optimization means a system crash can\n                corrupt the database or lose the last transactions if buffers\n                are not yet flushed to disk.\n            mode: File creation mode.\n            create: If False, do not create the directory `path` if it is\n                missing.\n            max_readers: Slots to allocate in lock file for read threads;\n                attempts to open the environment by more than this many clients\n                simultaneously will fail. only meaningful for environments that\n                aren't already open.\n            max_dbs: Maximum number of databases available. If 0, ""assume\n                environment will be used as a single database.\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_4lmdb_11Environment___init__;
#endif
static int __pyx_pw_4lmdb_11Environment_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  char const *__pyx_v_path;
  size_t __pyx_v_map_size;
  PyObject *__pyx_v_subdir = 0;
  PyObject *__pyx_v_readonly = 0;
  PyObject *__pyx_v_metasync = 0;
  PyObject *__pyx_v_sync = 0;
  PyObject *__pyx_v_map_async = 0;
  mode_t __pyx_v_mode;
  PyObject *__pyx_v_create = 0;
  int __pyx_v_max_readers;
  int __pyx_v_max_dbs;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__path,&__pyx_n_s__map_size,&__pyx_n_s__subdir,&__pyx_n_s__readonly,&__pyx_n_s__metasync,&__pyx_n_s__sync,&__pyx_n_s__map_async,&__pyx_n_s__mode,&__pyx_n_s__create,&__pyx_n_s__max_readers,&__pyx_n_s__max_dbs,0};
    PyObject* values[11] = {0,0,0,0,0,0,0,0,0,0,0};
    values[2] = __pyx_k_2;
    values[3] = __pyx_k_3;
    values[4] = __pyx_k_4;
    values[5] = __pyx_k_5;
    values[6] = __pyx_k_6;
    values[8] = __pyx_k_7;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__path)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__map_size);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__subdir);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__readonly);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__metasync);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__sync);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__map_async);
          if (value) { values[6] = value; kw_args--; }
        }
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__mode);
          if (value) { values[7] = value; kw_args--; }
        }
        case  8:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__create);
          if (value) { values[8] = value; kw_args--; }
        }
        case  9:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__max_readers);
          if (value) { values[9] = value; kw_args--; }
        }
        case 10:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__max_dbs);
          if (value) { values[10] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_path = PyBytes_AsString(values[0]); if (unlikely((!__pyx_v_path) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[1]) {
      __pyx_v_map_size = __Pyx_PyInt_AsSize_t(values[1]); if (unlikely((__pyx_v_map_size == (size_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_map_size = ((size_t)10485760);
    }
    __pyx_v_subdir = values[2];
    __pyx_v_readonly = values[3];
    __pyx_v_metasync = values[4];
    __pyx_v_sync = values[5];
    __pyx_v_map_async = values[6];
    if (values[7]) {
      __pyx_v_mode = __Pyx_PyInt_from_py_mode_t(values[7]); if (unlikely((__pyx_v_mode == (mode_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_mode = ((mode_t)0644);
    }
    __pyx_v_create = values[8];
    if (values[9]) {
      __pyx_v_max_readers = __Pyx_PyInt_AsInt(values[9]); if (unlikely((__pyx_v_max_readers == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_max_readers = ((int)126);
    }
    if (values[10]) {
      __pyx_v_max_dbs = __Pyx_PyInt_AsInt(values[10]); if (unlikely((__pyx_v_max_dbs == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_max_dbs = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 11, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Environment.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_11Environment___init__(((struct __pyx_obj_4lmdb_Environment *)__pyx_v_self), __pyx_v_path, __pyx_v_map_size, __pyx_v_subdir, __pyx_v_readonly, __pyx_v_metasync, __pyx_v_sync, __pyx_v_map_async, __pyx_v_mode, __pyx_v_create, __pyx_v_max_readers, __pyx_v_max_dbs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":184
 *     cdef MDB_env *env_
 * 
 *     def __init__(self, const char *path, size_t map_size=10485760,             # <<<<<<<<<<<<<<
 *             subdir=True, readonly=False, metasync=True,
 *             sync=True, map_async=False, mode_t mode=0644,
 */

static int __pyx_pf_4lmdb_11Environment___init__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self, char const *__pyx_v_path, size_t __pyx_v_map_size, PyObject *__pyx_v_subdir, PyObject *__pyx_v_readonly, PyObject *__pyx_v_metasync, PyObject *__pyx_v_sync, PyObject *__pyx_v_map_async, mode_t __pyx_v_mode, PyObject *__pyx_v_create, int __pyx_v_max_readers, int __pyx_v_max_dbs) {
  PyObject *__pyx_v_flags = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  unsigned int __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "lmdb.pyx":224
 *                 environment will be used as a single database.
 *         """
 *         _throw("Creating environment", mdb_env_create(&self.env_))             # <<<<<<<<<<<<<<
 *         _throw("Setting map size", mdb_env_set_mapsize(self.env_, map_size))
 *         _throw("Setting max readers",
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_8, mdb_env_create((&__pyx_v_self->env_))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":225
 *         """
 *         _throw("Creating environment", mdb_env_create(&self.env_))
 *         _throw("Setting map size", mdb_env_set_mapsize(self.env_, map_size))             # <<<<<<<<<<<<<<
 *         _throw("Setting max readers",
 *                mdb_env_set_maxreaders(self.env_, max_readers))
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_9, mdb_env_set_mapsize(__pyx_v_self->env_, __pyx_v_map_size)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":227
 *         _throw("Setting map size", mdb_env_set_mapsize(self.env_, map_size))
 *         _throw("Setting max readers",
 *                mdb_env_set_maxreaders(self.env_, max_readers))             # <<<<<<<<<<<<<<
 *         _throw("Setting max DBs", mdb_env_set_maxdbs(self.env_, max_dbs))
 * 
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_10, mdb_env_set_maxreaders(__pyx_v_self->env_, __pyx_v_max_readers)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":228
 *         _throw("Setting max readers",
 *                mdb_env_set_maxreaders(self.env_, max_readers))
 *         _throw("Setting max DBs", mdb_env_set_maxdbs(self.env_, max_dbs))             # <<<<<<<<<<<<<<
 * 
 *         flags = 0
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_11, mdb_env_set_maxdbs(__pyx_v_self->env_, __pyx_v_max_dbs)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":230
 *         _throw("Setting max DBs", mdb_env_set_maxdbs(self.env_, max_dbs))
 * 
 *         flags = 0             # <<<<<<<<<<<<<<
 *         if not subdir:
 *             flags |= MDB_NOSUBDIR
 */
  __Pyx_INCREF(__pyx_int_0);
  __pyx_v_flags = __pyx_int_0;

  /* "lmdb.pyx":231
 * 
 *         flags = 0
 *         if not subdir:             # <<<<<<<<<<<<<<
 *             flags |= MDB_NOSUBDIR
 *         if readonly:
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_subdir); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = (!__pyx_t_2);
  if (__pyx_t_3) {

    /* "lmdb.pyx":232
 *         flags = 0
 *         if not subdir:
 *             flags |= MDB_NOSUBDIR             # <<<<<<<<<<<<<<
 *         if readonly:
 *             flags |= MDB_RDONLY
 */
    __pyx_t_1 = PyInt_FromLong(MDB_NOSUBDIR); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = PyNumber_InPlaceOr(__pyx_v_flags, __pyx_t_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_v_flags);
    __pyx_v_flags = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "lmdb.pyx":233
 *         if not subdir:
 *             flags |= MDB_NOSUBDIR
 *         if readonly:             # <<<<<<<<<<<<<<
 *             flags |= MDB_RDONLY
 *         if not metasync:
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_readonly); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_3) {

    /* "lmdb.pyx":234
 *             flags |= MDB_NOSUBDIR
 *         if readonly:
 *             flags |= MDB_RDONLY             # <<<<<<<<<<<<<<
 *         if not metasync:
 *             flags |= MDB_NOMETASYNC
 */
    __pyx_t_4 = PyInt_FromLong(MDB_RDONLY); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = PyNumber_InPlaceOr(__pyx_v_flags, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_v_flags);
    __pyx_v_flags = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "lmdb.pyx":235
 *         if readonly:
 *             flags |= MDB_RDONLY
 *         if not metasync:             # <<<<<<<<<<<<<<
 *             flags |= MDB_NOMETASYNC
 *         if not sync:
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_metasync); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = (!__pyx_t_3);
  if (__pyx_t_2) {

    /* "lmdb.pyx":236
 *             flags |= MDB_RDONLY
 *         if not metasync:
 *             flags |= MDB_NOMETASYNC             # <<<<<<<<<<<<<<
 *         if not sync:
 *             flags |= MDB_NOSYNC
 */
    __pyx_t_1 = PyInt_FromLong(MDB_NOMETASYNC); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = PyNumber_InPlaceOr(__pyx_v_flags, __pyx_t_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_v_flags);
    __pyx_v_flags = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "lmdb.pyx":237
 *         if not metasync:
 *             flags |= MDB_NOMETASYNC
 *         if not sync:             # <<<<<<<<<<<<<<
 *             flags |= MDB_NOSYNC
 *         if map_async:
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_sync); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = (!__pyx_t_2);
  if (__pyx_t_3) {

    /* "lmdb.pyx":238
 *             flags |= MDB_NOMETASYNC
 *         if not sync:
 *             flags |= MDB_NOSYNC             # <<<<<<<<<<<<<<
 *         if map_async:
 *             flags |= MDB_MAPASYNC
 */
    __pyx_t_4 = PyInt_FromLong(MDB_NOSYNC); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 238; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = PyNumber_InPlaceOr(__pyx_v_flags, __pyx_t_4); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 238; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_v_flags);
    __pyx_v_flags = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "lmdb.pyx":239
 *         if not sync:
 *             flags |= MDB_NOSYNC
 *         if map_async:             # <<<<<<<<<<<<<<
 *             flags |= MDB_MAPASYNC
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_map_async); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_3) {

    /* "lmdb.pyx":240
 *             flags |= MDB_NOSYNC
 *         if map_async:
 *             flags |= MDB_MAPASYNC             # <<<<<<<<<<<<<<
 * 
 *         if create and subdir and not os.path.exists(path):
 */
    __pyx_t_1 = PyInt_FromLong(MDB_MAPASYNC); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = PyNumber_InPlaceOr(__pyx_v_flags, __pyx_t_1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_v_flags);
    __pyx_v_flags = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "lmdb.pyx":242
 *             flags |= MDB_MAPASYNC
 * 
 *         if create and subdir and not os.path.exists(path):             # <<<<<<<<<<<<<<
 *             os.mkdir(path)
 *         _throw(path, mdb_env_open(self.env_, path, flags, mode))
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_create); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_3) {
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_subdir); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (__pyx_t_2) {
      __pyx_t_4 = __Pyx_GetName(__pyx_m, __pyx_n_s__os); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_1 = PyObject_GetAttr(__pyx_t_4, __pyx_n_s__path); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__exists); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PyBytes_FromString(__pyx_v_path); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_5, 0, ((PyObject *)__pyx_t_1));
      __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
      __pyx_t_1 = 0;
      __pyx_t_1 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_7 = (!__pyx_t_6);
      __pyx_t_6 = __pyx_t_7;
    } else {
      __pyx_t_6 = __pyx_t_2;
    }
    __pyx_t_2 = __pyx_t_6;
  } else {
    __pyx_t_2 = __pyx_t_3;
  }
  if (__pyx_t_2) {

    /* "lmdb.pyx":243
 * 
 *         if create and subdir and not os.path.exists(path):
 *             os.mkdir(path)             # <<<<<<<<<<<<<<
 *         _throw(path, mdb_env_open(self.env_, path, flags, mode))
 * 
 */
    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__os); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = PyObject_GetAttr(__pyx_t_1, __pyx_n_s__mkdir); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyBytes_FromString(__pyx_v_path); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_1));
    __Pyx_GIVEREF(((PyObject *)__pyx_t_1));
    __pyx_t_1 = 0;
    __pyx_t_1 = PyObject_Call(__pyx_t_5, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 243; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L8;
  }
  __pyx_L8:;

  /* "lmdb.pyx":244
 *         if create and subdir and not os.path.exists(path):
 *             os.mkdir(path)
 *         _throw(path, mdb_env_open(self.env_, path, flags, mode))             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_t_8 = __Pyx_PyInt_AsUnsignedInt(__pyx_v_flags); if (unlikely((__pyx_t_8 == (unsigned int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_v_path, mdb_env_open(__pyx_v_self->env_, __pyx_v_path, __pyx_t_8, __pyx_v_mode)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("lmdb.Environment.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_flags);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static void __pyx_pw_4lmdb_11Environment_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_4lmdb_11Environment_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_4lmdb_11Environment_2__dealloc__(((struct __pyx_obj_4lmdb_Environment *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
}

/* "lmdb.pyx":246
 *         _throw(path, mdb_env_open(self.env_, path, flags, mode))
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         mdb_env_close(self.env_)
 * 
 */

static void __pyx_pf_4lmdb_11Environment_2__dealloc__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "lmdb.pyx":247
 * 
 *     def __dealloc__(self):
 *         mdb_env_close(self.env_)             # <<<<<<<<<<<<<<
 * 
 *     property path:
 */
  mdb_env_close(__pyx_v_self->env_);

  __Pyx_RefNannyFinishContext();
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Environment_4path_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_4lmdb_11Environment_4path_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_11Environment_4path___get__(((struct __pyx_obj_4lmdb_Environment *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":252
 *         """Directory path or file name prefix where this environment is
 *         stored."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             cdef const char *path
 *             mdb_env_get_path(self.env_, &path)
 */

static PyObject *__pyx_pf_4lmdb_11Environment_4path___get__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self) {
  char const *__pyx_v_path;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "lmdb.pyx":254
 *         def __get__(self):
 *             cdef const char *path
 *             mdb_env_get_path(self.env_, &path)             # <<<<<<<<<<<<<<
 *             return path
 * 
 */
  mdb_env_get_path(__pyx_v_self->env_, (&__pyx_v_path));

  /* "lmdb.pyx":255
 *             cdef const char *path
 *             mdb_env_get_path(self.env_, &path)
 *             return path             # <<<<<<<<<<<<<<
 * 
 *     property max_readers:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyBytes_FromString(__pyx_v_path); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __pyx_r = ((PyObject *)__pyx_t_1);
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Environment.path.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Environment_11max_readers_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_4lmdb_11Environment_11max_readers_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_11Environment_11max_readers___get__(((struct __pyx_obj_4lmdb_Environment *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":260
 *         """Maximum number of client threads that may read this environment
 *         simultaneously."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             cdef unsigned int readers
 *             mdb_env_get_maxreaders(self.env_, &readers)
 */

static PyObject *__pyx_pf_4lmdb_11Environment_11max_readers___get__(struct __pyx_obj_4lmdb_Environment *__pyx_v_self) {
  unsigned int __pyx_v_readers;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "lmdb.pyx":262
 *         def __get__(self):
 *             cdef unsigned int readers
 *             mdb_env_get_maxreaders(self.env_, &readers)             # <<<<<<<<<<<<<<
 *             return readers
 * 
 */
  mdb_env_get_maxreaders(__pyx_v_self->env_, (&__pyx_v_readers));

  /* "lmdb.pyx":263
 *             cdef unsigned int readers
 *             mdb_env_get_maxreaders(self.env_, &readers)
 *             return readers             # <<<<<<<<<<<<<<
 * 
 *     def sync(self, force=False):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyLong_FromUnsignedLong(__pyx_v_readers); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Environment.max_readers.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Environment_5sync(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_11Environment_4sync[] = "sync(force=False)\n\n        Flush the data buffers to disk.\n\n        Data is always written to disk when #mdb_txn_commit() is called, but\n        the operating system may keep it buffered. MDB always flushes the OS\n        buffers upon commit as well, unless the environment was opened with\n        #MDB_NOSYNC or in part #MDB_NOMETASYNC.\n     \n        @param[in] env An environment handle returned by #mdb_env_create()\n\t    @param[in] force If non-zero, force a synchronous flush.\n        \n        Otherwise if the environment has the #MDB_NOSYNC flag set the flushes\n        will be omitted, and with #MDB_MAPASYNC they will be asynchronous.\n        ";
static PyObject *__pyx_pw_4lmdb_11Environment_5sync(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_force = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("sync (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__force,0};
    PyObject* values[1] = {0};
    values[0] = __pyx_k_12;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__force);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sync") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_force = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("sync", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Environment.sync", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_11Environment_4sync(((struct __pyx_obj_4lmdb_Environment *)__pyx_v_self), __pyx_v_force);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":265
 *             return readers
 * 
 *     def sync(self, force=False):             # <<<<<<<<<<<<<<
 *         """sync(force=False)
 * 
 */

static PyObject *__pyx_pf_4lmdb_11Environment_4sync(struct __pyx_obj_4lmdb_Environment *__pyx_v_self, PyObject *__pyx_v_force) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("sync", 0);

  /* "lmdb.pyx":281
 *         will be omitted, and with #MDB_MAPASYNC they will be asynchronous.
 *         """
 *         _throw("Flushing", mdb_env_sync(self.env_, force))             # <<<<<<<<<<<<<<
 * 
 *     def stat(self):
 */
  __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_v_force); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = __pyx_f_4lmdb__throw(__pyx_k__Flushing, mdb_env_sync(__pyx_v_self->env_, __pyx_t_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Environment.sync", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Environment_7stat(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_11Environment_6stat[] = "stat()\n\n        Return some nice environment statistics as a dict:\n            psize: Size of a database page.\n            depth: Height of the B-tree.\n            branch_pages: Number of internal (non-leaf) pages.\n            leaf_pages: Number of leaf pages.\n            overflow_pages: Number of overflow pages.\n            entries: Number of data items.\n        ";
static PyObject *__pyx_pw_4lmdb_11Environment_7stat(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("stat (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_11Environment_6stat(((struct __pyx_obj_4lmdb_Environment *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":283
 *         _throw("Flushing", mdb_env_sync(self.env_, force))
 * 
 *     def stat(self):             # <<<<<<<<<<<<<<
 *         """stat()
 * 
 */

static PyObject *__pyx_pf_4lmdb_11Environment_6stat(struct __pyx_obj_4lmdb_Environment *__pyx_v_self) {
  struct MDB_stat __pyx_v_st;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("stat", 0);

  /* "lmdb.pyx":296
 *         cdef MDB_stat st
 *         _throw("Getting environment statistics",
 *                mdb_env_stat(self.env_, &st))             # <<<<<<<<<<<<<<
 *         return {
 *             "psize": st.ms_psize,
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_13, mdb_env_stat(__pyx_v_self->env_, (&__pyx_v_st))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":297
 *         _throw("Getting environment statistics",
 *                mdb_env_stat(self.env_, &st))
 *         return {             # <<<<<<<<<<<<<<
 *             "psize": st.ms_psize,
 *             "depth": st.ms_depth,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));

  /* "lmdb.pyx":298
 *                mdb_env_stat(self.env_, &st))
 *         return {
 *             "psize": st.ms_psize,             # <<<<<<<<<<<<<<
 *             "depth": st.ms_depth,
 *             "branch_pages": st.ms_branch_pages,
 */
  __pyx_t_2 = PyLong_FromUnsignedLong(__pyx_v_st.ms_psize); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__psize), __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "lmdb.pyx":299
 *         return {
 *             "psize": st.ms_psize,
 *             "depth": st.ms_depth,             # <<<<<<<<<<<<<<
 *             "branch_pages": st.ms_branch_pages,
 *             "leaf_pages": st.ms_leaf_pages,
 */
  __pyx_t_2 = PyLong_FromUnsignedLong(__pyx_v_st.ms_depth); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__depth), __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "lmdb.pyx":300
 *             "psize": st.ms_psize,
 *             "depth": st.ms_depth,
 *             "branch_pages": st.ms_branch_pages,             # <<<<<<<<<<<<<<
 *             "leaf_pages": st.ms_leaf_pages,
 *             "overflow_pages": st.ms_overflow_pages,
 */
  __pyx_t_2 = __Pyx_PyInt_FromSize_t(__pyx_v_st.ms_branch_pages); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__branch_pages), __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "lmdb.pyx":301
 *             "depth": st.ms_depth,
 *             "branch_pages": st.ms_branch_pages,
 *             "leaf_pages": st.ms_leaf_pages,             # <<<<<<<<<<<<<<
 *             "overflow_pages": st.ms_overflow_pages,
 *             "entries": st.ms_entries
 */
  __pyx_t_2 = __Pyx_PyInt_FromSize_t(__pyx_v_st.ms_leaf_pages); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__leaf_pages), __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "lmdb.pyx":302
 *             "branch_pages": st.ms_branch_pages,
 *             "leaf_pages": st.ms_leaf_pages,
 *             "overflow_pages": st.ms_overflow_pages,             # <<<<<<<<<<<<<<
 *             "entries": st.ms_entries
 *         }
 */
  __pyx_t_2 = __Pyx_PyInt_FromSize_t(__pyx_v_st.ms_overflow_pages); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 302; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__overflow_pages), __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "lmdb.pyx":303
 *             "leaf_pages": st.ms_leaf_pages,
 *             "overflow_pages": st.ms_overflow_pages,
 *             "entries": st.ms_entries             # <<<<<<<<<<<<<<
 *         }
 * 
 */
  __pyx_t_2 = __Pyx_PyInt_FromSize_t(__pyx_v_st.ms_entries); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, ((PyObject *)__pyx_n_s__entries), __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = ((PyObject *)__pyx_t_1);
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Environment.stat", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Environment_9transaction(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_11Environment_8transaction[] = "transaction(parent=None, readonly=False)\n\n        Shortcut for lmdb.Transaction(self, **kwargs)\n        ";
static PyObject *__pyx_pw_4lmdb_11Environment_9transaction(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_kwargs = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("transaction (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("transaction", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return NULL;}
  if (__pyx_kwds && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "transaction", 1))) return NULL;
  __pyx_v_kwargs = (__pyx_kwds) ? PyDict_Copy(__pyx_kwds) : PyDict_New();
  if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  __pyx_r = __pyx_pf_4lmdb_11Environment_8transaction(((struct __pyx_obj_4lmdb_Environment *)__pyx_v_self), __pyx_v_kwargs);
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":306
 *         }
 * 
 *     def transaction(self, **kwargs):             # <<<<<<<<<<<<<<
 *         """transaction(parent=None, readonly=False)
 * 
 */

static PyObject *__pyx_pf_4lmdb_11Environment_8transaction(struct __pyx_obj_4lmdb_Environment *__pyx_v_self, PyObject *__pyx_v_kwargs) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("transaction", 0);

  /* "lmdb.pyx":311
 *         Shortcut for lmdb.Transaction(self, **kwargs)
 *         """
 *         return Transaction(self, **kwargs)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __pyx_t_2 = ((PyObject *)__pyx_v_kwargs);
  __Pyx_INCREF(__pyx_t_2);
  __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_4lmdb_Transaction)), ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lmdb.Environment.transaction", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":326
 *     cdef int readonly
 * 
 *     cdef _throw(self):             # <<<<<<<<<<<<<<
 *         """Raise an exception if this transaction is complete."""
 *         if not self.running:
 */

static PyObject *__pyx_f_4lmdb_11Transaction__throw(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_throw", 0);

  /* "lmdb.pyx":328
 *     cdef _throw(self):
 *         """Raise an exception if this transaction is complete."""
 *         if not self.running:             # <<<<<<<<<<<<<<
 *             raise Error("transaction already aborted or committed")
 * 
 */
  __pyx_t_1 = (!__pyx_v_self->running);
  if (__pyx_t_1) {

    /* "lmdb.pyx":329
 *         """Raise an exception if this transaction is complete."""
 *         if not self.running:
 *             raise Error("transaction already aborted or committed")             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self, Environment env not None, Transaction parent=None,
 */
    __pyx_t_2 = __Pyx_GetName(__pyx_m, __pyx_n_s__Error); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_k_tuple_15), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lmdb.Transaction._throw", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static int __pyx_pw_4lmdb_11Transaction_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_11Transaction___init__[] = "Transaction(env, parent=None, readonly=False)\n\n        Start a new transaction.\n            env: Environment the transaction should be on.\n            parent: None, or a parent transaction (see lmdb.h).\n            readonly: Read-only?\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_4lmdb_11Transaction___init__;
#endif
static int __pyx_pw_4lmdb_11Transaction_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_4lmdb_Environment *__pyx_v_env = 0;
  struct __pyx_obj_4lmdb_Transaction *__pyx_v_parent = 0;
  PyObject *__pyx_v_readonly = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__env,&__pyx_n_s__parent,&__pyx_n_s__readonly,0};
    PyObject* values[3] = {0,0,0};

    /* "lmdb.pyx":331
 *             raise Error("transaction already aborted or committed")
 * 
 *     def __init__(self, Environment env not None, Transaction parent=None,             # <<<<<<<<<<<<<<
 *             readonly=False):
 *         """Transaction(env, parent=None, readonly=False)
 */
    values[1] = (PyObject *)((struct __pyx_obj_4lmdb_Transaction *)Py_None);
    values[2] = __pyx_k_16;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__env)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__parent);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__readonly);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_env = ((struct __pyx_obj_4lmdb_Environment *)values[0]);
    __pyx_v_parent = ((struct __pyx_obj_4lmdb_Transaction *)values[1]);
    __pyx_v_readonly = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Transaction.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_env), __pyx_ptype_4lmdb_Environment, 0, "env", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_parent), __pyx_ptype_4lmdb_Transaction, 1, "parent", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_4lmdb_11Transaction___init__(((struct __pyx_obj_4lmdb_Transaction *)__pyx_v_self), __pyx_v_env, __pyx_v_parent, __pyx_v_readonly);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_4lmdb_11Transaction___init__(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self, struct __pyx_obj_4lmdb_Environment *__pyx_v_env, struct __pyx_obj_4lmdb_Transaction *__pyx_v_parent, PyObject *__pyx_v_readonly) {
  char const *__pyx_v_what;
  long __pyx_v_flags;
  MDB_txn *__pyx_v_parent_txn;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  MDB_txn *__pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "lmdb.pyx":340
 *             readonly: Read-only?
 *         """
 *         self.env = env             # <<<<<<<<<<<<<<
 *         self.readonly = readonly
 *         cdef const char *what
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_env));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_env));
  __Pyx_GOTREF(__pyx_v_self->env);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->env));
  __pyx_v_self->env = __pyx_v_env;

  /* "lmdb.pyx":341
 *         """
 *         self.env = env
 *         self.readonly = readonly             # <<<<<<<<<<<<<<
 *         cdef const char *what
 *         if readonly:
 */
  __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_v_readonly); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_self->readonly = __pyx_t_1;

  /* "lmdb.pyx":343
 *         self.readonly = readonly
 *         cdef const char *what
 *         if readonly:             # <<<<<<<<<<<<<<
 *             what = "Beginning read-only transaction"
 *             flags = MDB_RDONLY
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_readonly); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 343; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {

    /* "lmdb.pyx":344
 *         cdef const char *what
 *         if readonly:
 *             what = "Beginning read-only transaction"             # <<<<<<<<<<<<<<
 *             flags = MDB_RDONLY
 *         else:
 */
    __pyx_v_what = __pyx_k_17;

    /* "lmdb.pyx":345
 *         if readonly:
 *             what = "Beginning read-only transaction"
 *             flags = MDB_RDONLY             # <<<<<<<<<<<<<<
 *         else:
 *             what = "Beginning write transaction"
 */
    __pyx_v_flags = MDB_RDONLY;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "lmdb.pyx":347
 *             flags = MDB_RDONLY
 *         else:
 *             what = "Beginning write transaction"             # <<<<<<<<<<<<<<
 *             flags = 0
 *         cdef MDB_txn *parent_txn = parent.txn_ if parent else NULL
 */
    __pyx_v_what = __pyx_k_18;

    /* "lmdb.pyx":348
 *         else:
 *             what = "Beginning write transaction"
 *             flags = 0             # <<<<<<<<<<<<<<
 *         cdef MDB_txn *parent_txn = parent.txn_ if parent else NULL
 *         _throw(what, mdb_txn_begin(env.env_, parent_txn, flags, &self.txn_))
 */
    __pyx_v_flags = 0;
  }
  __pyx_L3:;

  /* "lmdb.pyx":349
 *             what = "Beginning write transaction"
 *             flags = 0
 *         cdef MDB_txn *parent_txn = parent.txn_ if parent else NULL             # <<<<<<<<<<<<<<
 *         _throw(what, mdb_txn_begin(env.env_, parent_txn, flags, &self.txn_))
 *         self.running = 1
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(((PyObject *)__pyx_v_parent)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_2) {
    __pyx_t_3 = __pyx_v_parent->txn_;
  } else {
    __pyx_t_3 = NULL;
  }
  __pyx_v_parent_txn = __pyx_t_3;

  /* "lmdb.pyx":350
 *             flags = 0
 *         cdef MDB_txn *parent_txn = parent.txn_ if parent else NULL
 *         _throw(what, mdb_txn_begin(env.env_, parent_txn, flags, &self.txn_))             # <<<<<<<<<<<<<<
 *         self.running = 1
 * 
 */
  __pyx_t_4 = __pyx_f_4lmdb__throw(__pyx_v_what, mdb_txn_begin(__pyx_v_env->env_, __pyx_v_parent_txn, __pyx_v_flags, (&__pyx_v_self->txn_))); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "lmdb.pyx":351
 *         cdef MDB_txn *parent_txn = parent.txn_ if parent else NULL
 *         _throw(what, mdb_txn_begin(env.env_, parent_txn, flags, &self.txn_))
 *         self.running = 1             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->running = 1;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("lmdb.Transaction.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static void __pyx_pw_4lmdb_11Transaction_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_4lmdb_11Transaction_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_4lmdb_11Transaction_2__dealloc__(((struct __pyx_obj_4lmdb_Transaction *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
}

/* "lmdb.pyx":353
 *         self.running = 1
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.running:
 *             self.running = 0
 */

static void __pyx_pf_4lmdb_11Transaction_2__dealloc__(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "lmdb.pyx":354
 * 
 *     def __dealloc__(self):
 *         if self.running:             # <<<<<<<<<<<<<<
 *             self.running = 0
 *             mdb_txn_abort(self.txn_)
 */
  if (__pyx_v_self->running) {

    /* "lmdb.pyx":355
 *     def __dealloc__(self):
 *         if self.running:
 *             self.running = 0             # <<<<<<<<<<<<<<
 *             mdb_txn_abort(self.txn_)
 * 
 */
    __pyx_v_self->running = 0;

    /* "lmdb.pyx":356
 *         if self.running:
 *             self.running = 0
 *             mdb_txn_abort(self.txn_)             # <<<<<<<<<<<<<<
 * 
 *     def db(self, **kwargs):
 */
    mdb_txn_abort(__pyx_v_self->txn_);
    goto __pyx_L3;
  }
  __pyx_L3:;

  __Pyx_RefNannyFinishContext();
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Transaction_5db(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_11Transaction_4db[] = "db(**kwargs)\n\n        Shorthand for lmdb.Database(self, **kwargs)\n        ";
static PyObject *__pyx_pw_4lmdb_11Transaction_5db(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_kwargs = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("db (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("db", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return NULL;}
  if (__pyx_kwds && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "db", 1))) return NULL;
  __pyx_v_kwargs = (__pyx_kwds) ? PyDict_Copy(__pyx_kwds) : PyDict_New();
  if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  __pyx_r = __pyx_pf_4lmdb_11Transaction_4db(((struct __pyx_obj_4lmdb_Transaction *)__pyx_v_self), __pyx_v_kwargs);
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":358
 *             mdb_txn_abort(self.txn_)
 * 
 *     def db(self, **kwargs):             # <<<<<<<<<<<<<<
 *         """db(**kwargs)
 * 
 */

static PyObject *__pyx_pf_4lmdb_11Transaction_4db(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self, PyObject *__pyx_v_kwargs) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("db", 0);

  /* "lmdb.pyx":363
 *         Shorthand for lmdb.Database(self, **kwargs)
 *         """
 *         return Database(self, **kwargs)             # <<<<<<<<<<<<<<
 * 
 *     def commit(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __pyx_t_2 = ((PyObject *)__pyx_v_kwargs);
  __Pyx_INCREF(__pyx_t_2);
  __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_4lmdb_Database)), ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lmdb.Transaction.db", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Transaction_7commit(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_11Transaction_6commit[] = "commit()\n\n        Commit the pending transaction.\n        ";
static PyObject *__pyx_pw_4lmdb_11Transaction_7commit(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("commit (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_11Transaction_6commit(((struct __pyx_obj_4lmdb_Transaction *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":365
 *         return Database(self, **kwargs)
 * 
 *     def commit(self):             # <<<<<<<<<<<<<<
 *         """commit()
 * 
 */

static PyObject *__pyx_pf_4lmdb_11Transaction_6commit(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("commit", 0);

  /* "lmdb.pyx":370
 *         Commit the pending transaction.
 *         """
 *         self._throw()             # <<<<<<<<<<<<<<
 *         try:
 *             _throw("Committing transaction", mdb_txn_commit(self.txn_))
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Transaction *)__pyx_v_self->__pyx_vtab)->_throw(__pyx_v_self); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":371
 *         """
 *         self._throw()
 *         try:             # <<<<<<<<<<<<<<
 *             _throw("Committing transaction", mdb_txn_commit(self.txn_))
 *         finally:
 */
  /*try:*/ {

    /* "lmdb.pyx":372
 *         self._throw()
 *         try:
 *             _throw("Committing transaction", mdb_txn_commit(self.txn_))             # <<<<<<<<<<<<<<
 *         finally:
 *             self.running = 0
 */
    __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_19, mdb_txn_commit(__pyx_v_self->txn_)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 372; __pyx_clineno = __LINE__; goto __pyx_L4;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":374
 *             _throw("Committing transaction", mdb_txn_commit(self.txn_))
 *         finally:
 *             self.running = 0             # <<<<<<<<<<<<<<
 * 
 *     def abort(self):
 */
  /*finally:*/ {
    int __pyx_why;
    PyObject *__pyx_exc_type, *__pyx_exc_value, *__pyx_exc_tb;
    int __pyx_exc_lineno;
    __pyx_exc_type = 0; __pyx_exc_value = 0; __pyx_exc_tb = 0; __pyx_exc_lineno = 0;
    __pyx_why = 0; goto __pyx_L5;
    __pyx_L4: {
      __pyx_why = 4;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_ErrFetch(&__pyx_exc_type, &__pyx_exc_value, &__pyx_exc_tb);
      __pyx_exc_lineno = __pyx_lineno;
      goto __pyx_L5;
    }
    __pyx_L5:;
    __pyx_v_self->running = 0;
    switch (__pyx_why) {
      case 4: {
        __Pyx_ErrRestore(__pyx_exc_type, __pyx_exc_value, __pyx_exc_tb);
        __pyx_lineno = __pyx_exc_lineno;
        __pyx_exc_type = 0;
        __pyx_exc_value = 0;
        __pyx_exc_tb = 0;
        goto __pyx_L1_error;
      }
    }
  }

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Transaction.commit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_11Transaction_9abort(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_11Transaction_8abort[] = "abort()\n\n        Abort the pending transaction.\n        ";
static PyObject *__pyx_pw_4lmdb_11Transaction_9abort(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("abort (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_11Transaction_8abort(((struct __pyx_obj_4lmdb_Transaction *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":376
 *             self.running = 0
 * 
 *     def abort(self):             # <<<<<<<<<<<<<<
 *         """abort()
 * 
 */

static PyObject *__pyx_pf_4lmdb_11Transaction_8abort(struct __pyx_obj_4lmdb_Transaction *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("abort", 0);

  /* "lmdb.pyx":381
 *         Abort the pending transaction.
 *         """
 *         self._throw()             # <<<<<<<<<<<<<<
 *         self.running = 0
 *         mdb_txn_abort(self.txn_)
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Transaction *)__pyx_v_self->__pyx_vtab)->_throw(__pyx_v_self); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":382
 *         """
 *         self._throw()
 *         self.running = 0             # <<<<<<<<<<<<<<
 *         mdb_txn_abort(self.txn_)
 * 
 */
  __pyx_v_self->running = 0;

  /* "lmdb.pyx":383
 *         self._throw()
 *         self.running = 0
 *         mdb_txn_abort(self.txn_)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  mdb_txn_abort(__pyx_v_self->txn_);

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Transaction.abort", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static int __pyx_pw_4lmdb_8Database_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_8Database___init__[] = "Database(txn, name=None, reverse_key=False, dupsort=False, create=True)\n\n        Get a reference to or create a database within an environment.\n            txn: Transaction.\n            reverse_key: If True, keys are compared from right to left (e.g. DNS\n                names)\n            dupsort: Duplicate keys may be used in the database. (Or, from\n                another perspective, keys may have multiple data items, stored\n                in sorted order.) By default keys must be unique and may have\n                only a single data item.\n            create: If True, create the database if it doesn't exist, otherwise\n                raise an exception.\n\n        The Python module does not yet fully support dupsort.\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_4lmdb_8Database___init__;
#endif
static int __pyx_pw_4lmdb_8Database_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_4lmdb_Transaction *__pyx_v_txn = 0;
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_reverse_key = 0;
  PyObject *__pyx_v_dupsort = 0;
  PyObject *__pyx_v_create = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__txn,&__pyx_n_s__name,&__pyx_n_s__reverse_key,&__pyx_n_s__dupsort,&__pyx_n_s__create,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "lmdb.pyx":394
 *     cdef int dropped
 * 
 *     def __init__(self, Transaction txn not None, name=None, reverse_key=False,             # <<<<<<<<<<<<<<
 *             dupsort=False, create=True):
 *         """Database(txn, name=None, reverse_key=False, dupsort=False, create=True)
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = __pyx_k_20;
    values[3] = __pyx_k_21;
    values[4] = __pyx_k_22;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__txn)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__name);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__reverse_key);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dupsort);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__create);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_txn = ((struct __pyx_obj_4lmdb_Transaction *)values[0]);
    __pyx_v_name = values[1];
    __pyx_v_reverse_key = values[2];
    __pyx_v_dupsort = values[3];
    __pyx_v_create = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Database.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_txn), __pyx_ptype_4lmdb_Transaction, 0, "txn", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_4lmdb_8Database___init__(((struct __pyx_obj_4lmdb_Database *)__pyx_v_self), __pyx_v_txn, __pyx_v_name, __pyx_v_reverse_key, __pyx_v_dupsort, __pyx_v_create);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_4lmdb_8Database___init__(struct __pyx_obj_4lmdb_Database *__pyx_v_self, struct __pyx_obj_4lmdb_Transaction *__pyx_v_txn, PyObject *__pyx_v_name, PyObject *__pyx_v_reverse_key, PyObject *__pyx_v_dupsort, PyObject *__pyx_v_create) {
  char const *__pyx_v_c_name;
  int __pyx_v_flags;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  char const *__pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "lmdb.pyx":411
 *         The Python module does not yet fully support dupsort.
 *         """
 *         self.txn = txn             # <<<<<<<<<<<<<<
 *         self.dropped = 0
 *         cdef const char *c_name = NULL
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_txn));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_txn));
  __Pyx_GOTREF(__pyx_v_self->txn);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->txn));
  __pyx_v_self->txn = __pyx_v_txn;

  /* "lmdb.pyx":412
 *         """
 *         self.txn = txn
 *         self.dropped = 0             # <<<<<<<<<<<<<<
 *         cdef const char *c_name = NULL
 *         if name:
 */
  __pyx_v_self->dropped = 0;

  /* "lmdb.pyx":413
 *         self.txn = txn
 *         self.dropped = 0
 *         cdef const char *c_name = NULL             # <<<<<<<<<<<<<<
 *         if name:
 *             c_name = name
 */
  __pyx_v_c_name = NULL;

  /* "lmdb.pyx":414
 *         self.dropped = 0
 *         cdef const char *c_name = NULL
 *         if name:             # <<<<<<<<<<<<<<
 *             c_name = name
 *         cdef int flags = 0
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_name); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "lmdb.pyx":415
 *         cdef const char *c_name = NULL
 *         if name:
 *             c_name = name             # <<<<<<<<<<<<<<
 *         cdef int flags = 0
 *         if reverse_key:
 */
    __pyx_t_2 = PyBytes_AsString(__pyx_v_name); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_c_name = __pyx_t_2;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "lmdb.pyx":416
 *         if name:
 *             c_name = name
 *         cdef int flags = 0             # <<<<<<<<<<<<<<
 *         if reverse_key:
 *             flags |= MDB_REVERSEKEY
 */
  __pyx_v_flags = 0;

  /* "lmdb.pyx":417
 *             c_name = name
 *         cdef int flags = 0
 *         if reverse_key:             # <<<<<<<<<<<<<<
 *             flags |= MDB_REVERSEKEY
 *         if dupsort:
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_reverse_key); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "lmdb.pyx":418
 *         cdef int flags = 0
 *         if reverse_key:
 *             flags |= MDB_REVERSEKEY             # <<<<<<<<<<<<<<
 *         if dupsort:
 *             flags |= MDB_DUPSORT
 */
    __pyx_v_flags = (__pyx_v_flags | MDB_REVERSEKEY);
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "lmdb.pyx":419
 *         if reverse_key:
 *             flags |= MDB_REVERSEKEY
 *         if dupsort:             # <<<<<<<<<<<<<<
 *             flags |= MDB_DUPSORT
 *         if create:
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_dupsort); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "lmdb.pyx":420
 *             flags |= MDB_REVERSEKEY
 *         if dupsort:
 *             flags |= MDB_DUPSORT             # <<<<<<<<<<<<<<
 *         if create:
 *             flags |= MDB_CREATE
 */
    __pyx_v_flags = (__pyx_v_flags | MDB_DUPSORT);
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "lmdb.pyx":421
 *         if dupsort:
 *             flags |= MDB_DUPSORT
 *         if create:             # <<<<<<<<<<<<<<
 *             flags |= MDB_CREATE
 *         _throw("Opening database",
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_create); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "lmdb.pyx":422
 *             flags |= MDB_DUPSORT
 *         if create:
 *             flags |= MDB_CREATE             # <<<<<<<<<<<<<<
 *         _throw("Opening database",
 *                mdb_dbi_open(self.txn.txn_, c_name, flags, &self.dbi_))
 */
    __pyx_v_flags = (__pyx_v_flags | MDB_CREATE);
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "lmdb.pyx":424
 *             flags |= MDB_CREATE
 *         _throw("Opening database",
 *                mdb_dbi_open(self.txn.txn_, c_name, flags, &self.dbi_))             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_t_3 = __pyx_f_4lmdb__throw(__pyx_k_23, mdb_dbi_open(__pyx_v_self->txn->txn_, __pyx_v_c_name, __pyx_v_flags, (&__pyx_v_self->dbi_))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lmdb.Database.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static void __pyx_pw_4lmdb_8Database_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_4lmdb_8Database_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_4lmdb_8Database_2__dealloc__(((struct __pyx_obj_4lmdb_Database *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
}

/* "lmdb.pyx":426
 *                mdb_dbi_open(self.txn.txn_, c_name, flags, &self.dbi_))
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.txn.running and not self.dropped:
 *             mdb_dbi_close(self.txn.env.env_, self.dbi_)
 */

static void __pyx_pf_4lmdb_8Database_2__dealloc__(struct __pyx_obj_4lmdb_Database *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "lmdb.pyx":427
 * 
 *     def __dealloc__(self):
 *         if self.txn.running and not self.dropped:             # <<<<<<<<<<<<<<
 *             mdb_dbi_close(self.txn.env.env_, self.dbi_)
 * 
 */
  if (__pyx_v_self->txn->running) {
    __pyx_t_1 = (!__pyx_v_self->dropped);
    __pyx_t_2 = __pyx_t_1;
  } else {
    __pyx_t_2 = __pyx_v_self->txn->running;
  }
  if (__pyx_t_2) {

    /* "lmdb.pyx":428
 *     def __dealloc__(self):
 *         if self.txn.running and not self.dropped:
 *             mdb_dbi_close(self.txn.env.env_, self.dbi_)             # <<<<<<<<<<<<<<
 * 
 *     cdef _throw(self):
 */
    mdb_dbi_close(__pyx_v_self->txn->env->env_, __pyx_v_self->dbi_);
    goto __pyx_L3;
  }
  __pyx_L3:;

  __Pyx_RefNannyFinishContext();
}

/* "lmdb.pyx":430
 *             mdb_dbi_close(self.txn.env.env_, self.dbi_)
 * 
 *     cdef _throw(self):             # <<<<<<<<<<<<<<
 *         if self.dropped:
 *             raise Error("database was dropped.")
 */

static PyObject *__pyx_f_4lmdb_8Database__throw(struct __pyx_obj_4lmdb_Database *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_throw", 0);

  /* "lmdb.pyx":431
 * 
 *     cdef _throw(self):
 *         if self.dropped:             # <<<<<<<<<<<<<<
 *             raise Error("database was dropped.")
 *         self.txn._throw()
 */
  if (__pyx_v_self->dropped) {

    /* "lmdb.pyx":432
 *     cdef _throw(self):
 *         if self.dropped:
 *             raise Error("database was dropped.")             # <<<<<<<<<<<<<<
 *         self.txn._throw()
 * 
 */
    __pyx_t_1 = __Pyx_GetName(__pyx_m, __pyx_n_s__Error); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_k_tuple_25), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "lmdb.pyx":433
 *         if self.dropped:
 *             raise Error("database was dropped.")
 *         self.txn._throw()             # <<<<<<<<<<<<<<
 * 
 *     def drop(self, delete=True):
 */
  __pyx_t_2 = ((struct __pyx_vtabstruct_4lmdb_Transaction *)__pyx_v_self->txn->__pyx_vtab)->_throw(__pyx_v_self->txn); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Database._throw", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_8Database_5drop(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_8Database_4drop[] = "drop(delete=True)\n\n        Delete all keys and optionally delete the database itself. Deleting the\n        database causes it to become unavailable, and invalidates existing\n        cursors.\n        ";
static PyObject *__pyx_pw_4lmdb_8Database_5drop(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_delete = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("drop (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__delete,0};
    PyObject* values[1] = {0};
    values[0] = __pyx_k_26;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__delete);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "drop") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 435; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_delete = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("drop", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 435; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Database.drop", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_8Database_4drop(((struct __pyx_obj_4lmdb_Database *)__pyx_v_self), __pyx_v_delete);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":435
 *         self.txn._throw()
 * 
 *     def drop(self, delete=True):             # <<<<<<<<<<<<<<
 *         """drop(delete=True)
 * 
 */

static PyObject *__pyx_pf_4lmdb_8Database_4drop(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_delete) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("drop", 0);

  /* "lmdb.pyx":442
 *         cursors.
 *         """
 *         self._throw()             # <<<<<<<<<<<<<<
 *         mdb_drop(self.txn.txn_, self.dbi_, delete)
 *         if delete:
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->__pyx_vtab)->_throw(__pyx_v_self); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":443
 *         """
 *         self._throw()
 *         mdb_drop(self.txn.txn_, self.dbi_, delete)             # <<<<<<<<<<<<<<
 *         if delete:
 *             self.dropped = 1
 */
  __pyx_t_2 = __Pyx_PyInt_AsInt(__pyx_v_delete); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  mdb_drop(__pyx_v_self->txn->txn_, __pyx_v_self->dbi_, __pyx_t_2);

  /* "lmdb.pyx":444
 *         self._throw()
 *         mdb_drop(self.txn.txn_, self.dbi_, delete)
 *         if delete:             # <<<<<<<<<<<<<<
 *             self.dropped = 1
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_delete); if (unlikely(__pyx_t_3 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_3) {

    /* "lmdb.pyx":445
 *         mdb_drop(self.txn.txn_, self.dbi_, delete)
 *         if delete:
 *             self.dropped = 1             # <<<<<<<<<<<<<<
 * 
 *     def get(self, key, default=None):
 */
    __pyx_v_self->dropped = 1;
    goto __pyx_L3;
  }
  __pyx_L3:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Database.drop", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_8Database_7get(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_8Database_6get[] = "get(key, default=None)\n\n        Fetch the first value matching `key`, otherwise return `default`. A\n        cursor must be used to fetch all values for a key in a `dupsort=True`\n        database.\n        ";
static PyObject *__pyx_pw_4lmdb_8Database_7get(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_key = 0;
  PyObject *__pyx_v_default = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__key,&__pyx_n_s__default,0};
    PyObject* values[2] = {0,0};

    /* "lmdb.pyx":447
 *             self.dropped = 1
 * 
 *     def get(self, key, default=None):             # <<<<<<<<<<<<<<
 *         """get(key, default=None)
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__key)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__default);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 447; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_key = values[0];
    __pyx_v_default = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 447; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Database.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_8Database_6get(((struct __pyx_obj_4lmdb_Database *)__pyx_v_self), __pyx_v_key, __pyx_v_default);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_4lmdb_8Database_6get(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_default) {
  struct MDB_val __pyx_v_key_val;
  struct MDB_val __pyx_v_value_val;
  int __pyx_v_rc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  char *__pyx_t_3;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get", 0);

  /* "lmdb.pyx":454
 *         database.
 *         """
 *         self._throw()             # <<<<<<<<<<<<<<
 *         cdef MDB_val key_val
 *         cdef MDB_val value_val
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->__pyx_vtab)->_throw(__pyx_v_self); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":457
 *         cdef MDB_val key_val
 *         cdef MDB_val value_val
 *         key_val.mv_size = len(key)             # <<<<<<<<<<<<<<
 *         key_val.mv_data = <char *>key
 *         cdef int rc = mdb_get(self.txn.txn_, self.dbi_, &key_val, &value_val)
 */
  __pyx_t_2 = PyObject_Length(__pyx_v_key); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_key_val.mv_size = __pyx_t_2;

  /* "lmdb.pyx":458
 *         cdef MDB_val value_val
 *         key_val.mv_size = len(key)
 *         key_val.mv_data = <char *>key             # <<<<<<<<<<<<<<
 *         cdef int rc = mdb_get(self.txn.txn_, self.dbi_, &key_val, &value_val)
 *         if rc:
 */
  __pyx_t_3 = PyBytes_AsString(__pyx_v_key); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_key_val.mv_data = ((char *)__pyx_t_3);

  /* "lmdb.pyx":459
 *         key_val.mv_size = len(key)
 *         key_val.mv_data = <char *>key
 *         cdef int rc = mdb_get(self.txn.txn_, self.dbi_, &key_val, &value_val)             # <<<<<<<<<<<<<<
 *         if rc:
 *             if rc == MDB_NOTFOUND:
 */
  __pyx_v_rc = mdb_get(__pyx_v_self->txn->txn_, __pyx_v_self->dbi_, (&__pyx_v_key_val), (&__pyx_v_value_val));

  /* "lmdb.pyx":460
 *         key_val.mv_data = <char *>key
 *         cdef int rc = mdb_get(self.txn.txn_, self.dbi_, &key_val, &value_val)
 *         if rc:             # <<<<<<<<<<<<<<
 *             if rc == MDB_NOTFOUND:
 *                 return default
 */
  if (__pyx_v_rc) {

    /* "lmdb.pyx":461
 *         cdef int rc = mdb_get(self.txn.txn_, self.dbi_, &key_val, &value_val)
 *         if rc:
 *             if rc == MDB_NOTFOUND:             # <<<<<<<<<<<<<<
 *                 return default
 *             _throw("Getting key", rc)
 */
    __pyx_t_4 = (__pyx_v_rc == MDB_NOTFOUND);
    if (__pyx_t_4) {

      /* "lmdb.pyx":462
 *         if rc:
 *             if rc == MDB_NOTFOUND:
 *                 return default             # <<<<<<<<<<<<<<
 *             _throw("Getting key", rc)
 *         return <bytes> (<char *>value_val.mv_data)[:value_val.mv_size]
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_default);
      __pyx_r = __pyx_v_default;
      goto __pyx_L0;
      goto __pyx_L4;
    }
    __pyx_L4:;

    /* "lmdb.pyx":463
 *             if rc == MDB_NOTFOUND:
 *                 return default
 *             _throw("Getting key", rc)             # <<<<<<<<<<<<<<
 *         return <bytes> (<char *>value_val.mv_data)[:value_val.mv_size]
 * 
 */
    __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_27, __pyx_v_rc); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "lmdb.pyx":464
 *                 return default
 *             _throw("Getting key", rc)
 *         return <bytes> (<char *>value_val.mv_data)[:value_val.mv_size]             # <<<<<<<<<<<<<<
 * 
 *     def put(self, key, value, dupdata=False, overwrite=True, append=False):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyBytes_FromStringAndSize(((const char*)((char *)__pyx_v_value_val.mv_data)) + 0, __pyx_v_value_val.mv_size - 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(((PyObject *)((PyObject*)__pyx_t_1)));
  __pyx_r = ((PyObject *)__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Database.get", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_8Database_9put(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_8Database_8put[] = "put(key, value, dupdata=False, overwrite=True, append=False)\n\n        Store key/value pairs in the database.\n            key: String key to store.\n            value: String value to store.\n            dupdata: If True and database was opened with dupsort=True, add\n                pair as a duplicate if the given key already exists. Otherwise\n                overwrite any existing matching key.\n            overwrite: If False, do not overwrite any existing matching key.\n            append: If True, append the pair to the end of the database without\n                comparing its order first. Appending a key that is not greater\n                than the highest existing key will cause corruption.\n\n        Returns True if the pair was written or False to indicate the key was\n        already present and override=False.\n        ";
static PyObject *__pyx_pw_4lmdb_8Database_9put(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_key = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_v_dupdata = 0;
  PyObject *__pyx_v_overwrite = 0;
  PyObject *__pyx_v_append = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("put (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__key,&__pyx_n_s__value,&__pyx_n_s__dupdata,&__pyx_n_s__overwrite,&__pyx_n_s__append,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[2] = __pyx_k_28;
    values[3] = __pyx_k_29;
    values[4] = __pyx_k_30;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__key)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("put", 0, 2, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__dupdata);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__overwrite);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__append);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "put") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_key = values[0];
    __pyx_v_value = values[1];
    __pyx_v_dupdata = values[2];
    __pyx_v_overwrite = values[3];
    __pyx_v_append = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("put", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Database.put", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_8Database_8put(((struct __pyx_obj_4lmdb_Database *)__pyx_v_self), __pyx_v_key, __pyx_v_value, __pyx_v_dupdata, __pyx_v_overwrite, __pyx_v_append);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":466
 *         return <bytes> (<char *>value_val.mv_data)[:value_val.mv_size]
 * 
 *     def put(self, key, value, dupdata=False, overwrite=True, append=False):             # <<<<<<<<<<<<<<
 *         """put(key, value, dupdata=False, overwrite=True, append=False)
 * 
 */

static PyObject *__pyx_pf_4lmdb_8Database_8put(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_value, PyObject *__pyx_v_dupdata, PyObject *__pyx_v_overwrite, PyObject *__pyx_v_append) {
  struct MDB_val __pyx_v_key_val;
  struct MDB_val __pyx_v_value_val;
  int __pyx_v_flags;
  int __pyx_v_rc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  char *__pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("put", 0);

  /* "lmdb.pyx":483
 *         already present and override=False.
 *         """
 *         self._throw()             # <<<<<<<<<<<<<<
 *         cdef MDB_val key_val
 *         cdef MDB_val value_val
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->__pyx_vtab)->_throw(__pyx_v_self); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":487
 *         cdef MDB_val value_val
 * 
 *         key_val.mv_size = len(key)             # <<<<<<<<<<<<<<
 *         key_val.mv_data = <char *>key
 *         value_val.mv_size = len(value)
 */
  __pyx_t_2 = PyObject_Length(__pyx_v_key); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_key_val.mv_size = __pyx_t_2;

  /* "lmdb.pyx":488
 * 
 *         key_val.mv_size = len(key)
 *         key_val.mv_data = <char *>key             # <<<<<<<<<<<<<<
 *         value_val.mv_size = len(value)
 *         value_val.mv_data = <char *>value
 */
  __pyx_t_3 = PyBytes_AsString(__pyx_v_key); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_key_val.mv_data = ((char *)__pyx_t_3);

  /* "lmdb.pyx":489
 *         key_val.mv_size = len(key)
 *         key_val.mv_data = <char *>key
 *         value_val.mv_size = len(value)             # <<<<<<<<<<<<<<
 *         value_val.mv_data = <char *>value
 * 
 */
  __pyx_t_2 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 489; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_value_val.mv_size = __pyx_t_2;

  /* "lmdb.pyx":490
 *         key_val.mv_data = <char *>key
 *         value_val.mv_size = len(value)
 *         value_val.mv_data = <char *>value             # <<<<<<<<<<<<<<
 * 
 *         cdef int flags = 0
 */
  __pyx_t_3 = PyBytes_AsString(__pyx_v_value); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 490; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_value_val.mv_data = ((char *)__pyx_t_3);

  /* "lmdb.pyx":492
 *         value_val.mv_data = <char *>value
 * 
 *         cdef int flags = 0             # <<<<<<<<<<<<<<
 *         if not dupdata:
 *             flags |= MDB_NODUPDATA
 */
  __pyx_v_flags = 0;

  /* "lmdb.pyx":493
 * 
 *         cdef int flags = 0
 *         if not dupdata:             # <<<<<<<<<<<<<<
 *             flags |= MDB_NODUPDATA
 *         if not overwrite:
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_dupdata); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_5 = (!__pyx_t_4);
  if (__pyx_t_5) {

    /* "lmdb.pyx":494
 *         cdef int flags = 0
 *         if not dupdata:
 *             flags |= MDB_NODUPDATA             # <<<<<<<<<<<<<<
 *         if not overwrite:
 *             flags |= MDB_NOOVERWRITE
 */
    __pyx_v_flags = (__pyx_v_flags | MDB_NODUPDATA);
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "lmdb.pyx":495
 *         if not dupdata:
 *             flags |= MDB_NODUPDATA
 *         if not overwrite:             # <<<<<<<<<<<<<<
 *             flags |= MDB_NOOVERWRITE
 *         if append:
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_overwrite); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_4 = (!__pyx_t_5);
  if (__pyx_t_4) {

    /* "lmdb.pyx":496
 *             flags |= MDB_NODUPDATA
 *         if not overwrite:
 *             flags |= MDB_NOOVERWRITE             # <<<<<<<<<<<<<<
 *         if append:
 *             flags |= MDB_APPEND
 */
    __pyx_v_flags = (__pyx_v_flags | MDB_NOOVERWRITE);
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "lmdb.pyx":497
 *         if not overwrite:
 *             flags |= MDB_NOOVERWRITE
 *         if append:             # <<<<<<<<<<<<<<
 *             flags |= MDB_APPEND
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_append); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_4) {

    /* "lmdb.pyx":498
 *             flags |= MDB_NOOVERWRITE
 *         if append:
 *             flags |= MDB_APPEND             # <<<<<<<<<<<<<<
 * 
 *         cdef int rc = mdb_put(self.txn.txn_, self.dbi_,
 */
    __pyx_v_flags = (__pyx_v_flags | MDB_APPEND);
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "lmdb.pyx":501
 * 
 *         cdef int rc = mdb_put(self.txn.txn_, self.dbi_,
 *                               &key_val, &value_val, flags)             # <<<<<<<<<<<<<<
 *         if rc == MDB_KEYEXIST:
 *             return False
 */
  __pyx_v_rc = mdb_put(__pyx_v_self->txn->txn_, __pyx_v_self->dbi_, (&__pyx_v_key_val), (&__pyx_v_value_val), __pyx_v_flags);

  /* "lmdb.pyx":502
 *         cdef int rc = mdb_put(self.txn.txn_, self.dbi_,
 *                               &key_val, &value_val, flags)
 *         if rc == MDB_KEYEXIST:             # <<<<<<<<<<<<<<
 *             return False
 *         _throw("Setting key", rc)
 */
  __pyx_t_4 = (__pyx_v_rc == MDB_KEYEXIST);
  if (__pyx_t_4) {

    /* "lmdb.pyx":503
 *                               &key_val, &value_val, flags)
 *         if rc == MDB_KEYEXIST:
 *             return False             # <<<<<<<<<<<<<<
 *         _throw("Setting key", rc)
 *         return True
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "lmdb.pyx":504
 *         if rc == MDB_KEYEXIST:
 *             return False
 *         _throw("Setting key", rc)             # <<<<<<<<<<<<<<
 *         return True
 * 
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_31, __pyx_v_rc); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":505
 *             return False
 *         _throw("Setting key", rc)
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     def delete(self, key, value=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Database.put", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_8Database_11delete(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_8Database_10delete[] = "delete(key, value=None)\n\n        Delete a key from the database.\n            key: The key to delete.\n            value: If the database was opened with dupsort=True and value is\n                not None, then delete elements matching only this (key, value)\n                pair, otherwise all values for key are deleted.\n\n        Returns True if at least one key was deleted.\n        ";
static PyObject *__pyx_pw_4lmdb_8Database_11delete(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_key = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("delete (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__key,&__pyx_n_s__value,0};
    PyObject* values[2] = {0,0};

    /* "lmdb.pyx":507
 *         return True
 * 
 *     def delete(self, key, value=None):             # <<<<<<<<<<<<<<
 *         """delete(key, value=None)
 * 
 */
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__key)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__value);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "delete") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_key = values[0];
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("delete", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Database.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_8Database_10delete(((struct __pyx_obj_4lmdb_Database *)__pyx_v_self), __pyx_v_key, __pyx_v_value);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_4lmdb_8Database_10delete(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_value) {
  struct MDB_val __pyx_v_key_val;
  struct MDB_val __pyx_v_value_val;
  struct MDB_val *__pyx_v_val_ptr;
  int __pyx_v_rc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  char *__pyx_t_3;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("delete", 0);

  /* "lmdb.pyx":518
 *         Returns True if at least one key was deleted.
 *         """
 *         self._throw()             # <<<<<<<<<<<<<<
 *         cdef MDB_val key_val
 *         cdef MDB_val value_val
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->__pyx_vtab)->_throw(__pyx_v_self); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":522
 *         cdef MDB_val value_val
 *         cdef MDB_val *val_ptr
 *         key_val.mv_size = len(key)             # <<<<<<<<<<<<<<
 *         key_val.mv_data = <char *>key
 *         if value is None:
 */
  __pyx_t_2 = PyObject_Length(__pyx_v_key); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_key_val.mv_size = __pyx_t_2;

  /* "lmdb.pyx":523
 *         cdef MDB_val *val_ptr
 *         key_val.mv_size = len(key)
 *         key_val.mv_data = <char *>key             # <<<<<<<<<<<<<<
 *         if value is None:
 *             val_ptr = NULL
 */
  __pyx_t_3 = PyBytes_AsString(__pyx_v_key); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_key_val.mv_data = ((char *)__pyx_t_3);

  /* "lmdb.pyx":524
 *         key_val.mv_size = len(key)
 *         key_val.mv_data = <char *>key
 *         if value is None:             # <<<<<<<<<<<<<<
 *             val_ptr = NULL
 *         else:
 */
  __pyx_t_4 = (__pyx_v_value == Py_None);
  if (__pyx_t_4) {

    /* "lmdb.pyx":525
 *         key_val.mv_data = <char *>key
 *         if value is None:
 *             val_ptr = NULL             # <<<<<<<<<<<<<<
 *         else:
 *             value_val.mv_size = len(value)
 */
    __pyx_v_val_ptr = NULL;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "lmdb.pyx":527
 *             val_ptr = NULL
 *         else:
 *             value_val.mv_size = len(value)             # <<<<<<<<<<<<<<
 *             value_val.mv_data = <char *>value
 *             val_ptr = &value_val
 */
    __pyx_t_2 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 527; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_value_val.mv_size = __pyx_t_2;

    /* "lmdb.pyx":528
 *         else:
 *             value_val.mv_size = len(value)
 *             value_val.mv_data = <char *>value             # <<<<<<<<<<<<<<
 *             val_ptr = &value_val
 * 
 */
    __pyx_t_3 = PyBytes_AsString(__pyx_v_value); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_value_val.mv_data = ((char *)__pyx_t_3);

    /* "lmdb.pyx":529
 *             value_val.mv_size = len(value)
 *             value_val.mv_data = <char *>value
 *             val_ptr = &value_val             # <<<<<<<<<<<<<<
 * 
 *         cdef int rc = mdb_del(self.txn.txn_, self.dbi_, &key_val, val_ptr)
 */
    __pyx_v_val_ptr = (&__pyx_v_value_val);
  }
  __pyx_L3:;

  /* "lmdb.pyx":531
 *             val_ptr = &value_val
 * 
 *         cdef int rc = mdb_del(self.txn.txn_, self.dbi_, &key_val, val_ptr)             # <<<<<<<<<<<<<<
 *         if rc:
 *             if rc == MDB_NOTFOUND:
 */
  __pyx_v_rc = mdb_del(__pyx_v_self->txn->txn_, __pyx_v_self->dbi_, (&__pyx_v_key_val), __pyx_v_val_ptr);

  /* "lmdb.pyx":532
 * 
 *         cdef int rc = mdb_del(self.txn.txn_, self.dbi_, &key_val, val_ptr)
 *         if rc:             # <<<<<<<<<<<<<<
 *             if rc == MDB_NOTFOUND:
 *                 return False
 */
  if (__pyx_v_rc) {

    /* "lmdb.pyx":533
 *         cdef int rc = mdb_del(self.txn.txn_, self.dbi_, &key_val, val_ptr)
 *         if rc:
 *             if rc == MDB_NOTFOUND:             # <<<<<<<<<<<<<<
 *                 return False
 *             _throw("Deleting key", rc)
 */
    __pyx_t_4 = (__pyx_v_rc == MDB_NOTFOUND);
    if (__pyx_t_4) {

      /* "lmdb.pyx":534
 *         if rc:
 *             if rc == MDB_NOTFOUND:
 *                 return False             # <<<<<<<<<<<<<<
 *             _throw("Deleting key", rc)
 *         return True
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L0;
      goto __pyx_L5;
    }
    __pyx_L5:;

    /* "lmdb.pyx":535
 *             if rc == MDB_NOTFOUND:
 *                 return False
 *             _throw("Deleting key", rc)             # <<<<<<<<<<<<<<
 *         return True
 * 
 */
    __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_32, __pyx_v_rc); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "lmdb.pyx":536
 *                 return False
 *             _throw("Deleting key", rc)
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     def cursor(self, **kwargs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Database.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_8Database_13cursor(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_8Database_12cursor[] = "cursor(**kwargs)\n\n        Shorthand for lmdb.Cursor(self, **kwargs)\n        ";
static PyObject *__pyx_pw_4lmdb_8Database_13cursor(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_kwargs = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cursor (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("cursor", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return NULL;}
  if (__pyx_kwds && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "cursor", 1))) return NULL;
  __pyx_v_kwargs = (__pyx_kwds) ? PyDict_Copy(__pyx_kwds) : PyDict_New();
  if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  __pyx_r = __pyx_pf_4lmdb_8Database_12cursor(((struct __pyx_obj_4lmdb_Database *)__pyx_v_self), __pyx_v_kwargs);
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":538
 *         return True
 * 
 *     def cursor(self, **kwargs):             # <<<<<<<<<<<<<<
 *         """cursor(**kwargs)
 * 
 */

static PyObject *__pyx_pf_4lmdb_8Database_12cursor(struct __pyx_obj_4lmdb_Database *__pyx_v_self, PyObject *__pyx_v_kwargs) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("cursor", 0);

  /* "lmdb.pyx":543
 *         Shorthand for lmdb.Cursor(self, **kwargs)
 *         """
 *         return Cursor(self, **kwargs)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __pyx_t_2 = ((PyObject *)__pyx_v_kwargs);
  __Pyx_INCREF(__pyx_t_2);
  __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_4lmdb_Cursor)), ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lmdb.Database.cursor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static int __pyx_pw_4lmdb_6Cursor_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_4lmdb_6Cursor___init__[] = "Cursor(db, keys=True, values=True)\n\n        Create a new cursor. If both `keys` and `values` are True, the Python\n        iterator protocol applied to this object will yield ``(key, value)``\n        tuples, if only `value` is True then a sequence of values will be\n        generated, otherwise a sequence of keys will be generated.\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_4lmdb_6Cursor___init__;
#endif
static int __pyx_pw_4lmdb_6Cursor_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_4lmdb_Database *__pyx_v_db = 0;
  PyObject *__pyx_v_keys = 0;
  PyObject *__pyx_v_values = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__db,&__pyx_n_s__keys,&__pyx_n_s__values,0};
    PyObject* values[3] = {0,0,0};
    values[1] = __pyx_k_33;
    values[2] = __pyx_k_34;
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__db)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__keys);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__values);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_db = ((struct __pyx_obj_4lmdb_Database *)values[0]);
    __pyx_v_keys = values[1];
    __pyx_v_values = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Cursor.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_db), __pyx_ptype_4lmdb_Database, 0, "db", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_4lmdb_6Cursor___init__(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self), __pyx_v_db, __pyx_v_keys, __pyx_v_values);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":561
 *     cdef int do_values_
 * 
 *     def __init__(self, Database db not None, keys=True, values=True):             # <<<<<<<<<<<<<<
 *         """Cursor(db, keys=True, values=True)
 * 
 */

static int __pyx_pf_4lmdb_6Cursor___init__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, struct __pyx_obj_4lmdb_Database *__pyx_v_db, PyObject *__pyx_v_keys, PyObject *__pyx_v_values) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "lmdb.pyx":569
 *         generated, otherwise a sequence of keys will be generated.
 *         """
 *         self.db  = db             # <<<<<<<<<<<<<<
 *         self.txn = db.txn
 *         self.txn._throw()
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_db));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_db));
  __Pyx_GOTREF(__pyx_v_self->db);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->db));
  __pyx_v_self->db = __pyx_v_db;

  /* "lmdb.pyx":570
 *         """
 *         self.db  = db
 *         self.txn = db.txn             # <<<<<<<<<<<<<<
 *         self.txn._throw()
 *         self.do_keys_ = keys
 */
  __pyx_t_1 = ((PyObject *)__pyx_v_db->txn);
  __Pyx_INCREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->txn);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->txn));
  __pyx_v_self->txn = ((struct __pyx_obj_4lmdb_Transaction *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":571
 *         self.db  = db
 *         self.txn = db.txn
 *         self.txn._throw()             # <<<<<<<<<<<<<<
 *         self.do_keys_ = keys
 *         self.do_values_ = values
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Transaction *)__pyx_v_self->txn->__pyx_vtab)->_throw(__pyx_v_self->txn); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":572
 *         self.txn = db.txn
 *         self.txn._throw()
 *         self.do_keys_ = keys             # <<<<<<<<<<<<<<
 *         self.do_values_ = values
 *         # Sentinel indicating iteration has not started.
 */
  __pyx_t_2 = __Pyx_PyInt_AsInt(__pyx_v_keys); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_self->do_keys_ = __pyx_t_2;

  /* "lmdb.pyx":573
 *         self.txn._throw()
 *         self.do_keys_ = keys
 *         self.do_values_ = values             # <<<<<<<<<<<<<<
 *         # Sentinel indicating iteration has not started.
 *         self.key_.mv_data = NULL
 */
  __pyx_t_2 = __Pyx_PyInt_AsInt(__pyx_v_values); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_self->do_values_ = __pyx_t_2;

  /* "lmdb.pyx":575
 *         self.do_values_ = values
 *         # Sentinel indicating iteration has not started.
 *         self.key_.mv_data = NULL             # <<<<<<<<<<<<<<
 *         self.key_.mv_size = 0
 *         self.val_.mv_data = NULL
 */
  __pyx_v_self->key_.mv_data = NULL;

  /* "lmdb.pyx":576
 *         # Sentinel indicating iteration has not started.
 *         self.key_.mv_data = NULL
 *         self.key_.mv_size = 0             # <<<<<<<<<<<<<<
 *         self.val_.mv_data = NULL
 *         self.val_.mv_size = 0
 */
  __pyx_v_self->key_.mv_size = 0;

  /* "lmdb.pyx":577
 *         self.key_.mv_data = NULL
 *         self.key_.mv_size = 0
 *         self.val_.mv_data = NULL             # <<<<<<<<<<<<<<
 *         self.val_.mv_size = 0
 *         _throw("Creating cursor",
 */
  __pyx_v_self->val_.mv_data = NULL;

  /* "lmdb.pyx":578
 *         self.key_.mv_size = 0
 *         self.val_.mv_data = NULL
 *         self.val_.mv_size = 0             # <<<<<<<<<<<<<<
 *         _throw("Creating cursor",
 *                mdb_cursor_open(self.txn.txn_, db.dbi_, &self.cursor_))
 */
  __pyx_v_self->val_.mv_size = 0;

  /* "lmdb.pyx":580
 *         self.val_.mv_size = 0
 *         _throw("Creating cursor",
 *                mdb_cursor_open(self.txn.txn_, db.dbi_, &self.cursor_))             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_35, mdb_cursor_open(__pyx_v_self->txn->txn_, __pyx_v_db->dbi_, (&__pyx_v_self->cursor_))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static void __pyx_pw_4lmdb_6Cursor_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_4lmdb_6Cursor_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_4lmdb_6Cursor_2__dealloc__(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
}

/* "lmdb.pyx":582
 *                mdb_cursor_open(self.txn.txn_, db.dbi_, &self.cursor_))
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.txn.running:
 *             mdb_cursor_close(self.cursor_)
 */

static void __pyx_pf_4lmdb_6Cursor_2__dealloc__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "lmdb.pyx":583
 * 
 *     def __dealloc__(self):
 *         if self.txn.running:             # <<<<<<<<<<<<<<
 *             mdb_cursor_close(self.cursor_)
 * 
 */
  if (__pyx_v_self->txn->running) {

    /* "lmdb.pyx":584
 *     def __dealloc__(self):
 *         if self.txn.running:
 *             mdb_cursor_close(self.cursor_)             # <<<<<<<<<<<<<<
 * 
 *     cpdef _throw_stop(self, const char *what, int rc):
 */
    mdb_cursor_close(__pyx_v_self->cursor_);
    goto __pyx_L3;
  }
  __pyx_L3:;

  __Pyx_RefNannyFinishContext();
}

/* "lmdb.pyx":586
 *             mdb_cursor_close(self.cursor_)
 * 
 *     cpdef _throw_stop(self, const char *what, int rc):             # <<<<<<<<<<<<<<
 *         if rc == MDB_NOTFOUND:
 *             raise StopIteration
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_5_throw_stop(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor__throw_stop(CYTHON_UNUSED struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, char const *__pyx_v_what, int __pyx_v_rc, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_throw_stop", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s___throw_stop); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_5_throw_stop)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyBytes_FromString(__pyx_v_what); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
      __pyx_t_3 = PyInt_FromLong(__pyx_v_rc); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_2));
      __Pyx_GIVEREF(((PyObject *)__pyx_t_2));
      PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_3);
      __pyx_t_2 = 0;
      __pyx_t_3 = 0;
      __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
      __pyx_r = __pyx_t_3;
      __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":587
 * 
 *     cpdef _throw_stop(self, const char *what, int rc):
 *         if rc == MDB_NOTFOUND:             # <<<<<<<<<<<<<<
 *             raise StopIteration
 *         _throw(what, rc)
 */
  __pyx_t_5 = (__pyx_v_rc == MDB_NOTFOUND);
  if (__pyx_t_5) {

    /* "lmdb.pyx":588
 *     cpdef _throw_stop(self, const char *what, int rc):
 *         if rc == MDB_NOTFOUND:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 *         _throw(what, rc)
 * 
 */
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "lmdb.pyx":589
 *         if rc == MDB_NOTFOUND:
 *             raise StopIteration
 *         _throw(what, rc)             # <<<<<<<<<<<<<<
 * 
 *     cpdef _cursor_get(self, MDB_cursor_op op):
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_v_what, __pyx_v_rc); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 589; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("lmdb.Cursor._throw_stop", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_5_throw_stop(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_5_throw_stop(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  char const *__pyx_v_what;
  int __pyx_v_rc;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_throw_stop (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__what,&__pyx_n_s__rc,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__what)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__rc)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_throw_stop", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_throw_stop") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_what = PyBytes_AsString(values[0]); if (unlikely((!__pyx_v_what) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_rc = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_rc == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_throw_stop", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Cursor._throw_stop", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_6Cursor_4_throw_stop(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self), __pyx_v_what, __pyx_v_rc);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":586
 *             mdb_cursor_close(self.cursor_)
 * 
 *     cpdef _throw_stop(self, const char *what, int rc):             # <<<<<<<<<<<<<<
 *         if rc == MDB_NOTFOUND:
 *             raise StopIteration
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_4_throw_stop(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, char const *__pyx_v_what, int __pyx_v_rc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_throw_stop", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_throw_stop(__pyx_v_self, __pyx_v_what, __pyx_v_rc, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor._throw_stop", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":591
 *         _throw(what, rc)
 * 
 *     cpdef _cursor_get(self, MDB_cursor_op op):             # <<<<<<<<<<<<<<
 *         self.db._throw()
 *         rc = mdb_cursor_get(self.cursor_, &self.key_, &self.val_, op)
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_7_cursor_get(PyObject *__pyx_v_self, PyObject *__pyx_arg_op); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor__cursor_get(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, MDB_cursor_op __pyx_v_op, int __pyx_skip_dispatch) {
  int __pyx_v_rc;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_cursor_get", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s___cursor_get); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_7_cursor_get)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyInt_FromLong(__pyx_v_op); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":592
 * 
 *     cpdef _cursor_get(self, MDB_cursor_op op):
 *         self.db._throw()             # <<<<<<<<<<<<<<
 *         rc = mdb_cursor_get(self.cursor_, &self.key_, &self.val_, op)
 *         self._throw_stop("Advancing cursor", rc)
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->db->__pyx_vtab)->_throw(__pyx_v_self->db); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":593
 *     cpdef _cursor_get(self, MDB_cursor_op op):
 *         self.db._throw()
 *         rc = mdb_cursor_get(self.cursor_, &self.key_, &self.val_, op)             # <<<<<<<<<<<<<<
 *         self._throw_stop("Advancing cursor", rc)
 * 
 */
  __pyx_v_rc = mdb_cursor_get(__pyx_v_self->cursor_, (&__pyx_v_self->key_), (&__pyx_v_self->val_), __pyx_v_op);

  /* "lmdb.pyx":594
 *         self.db._throw()
 *         rc = mdb_cursor_get(self.cursor_, &self.key_, &self.val_, op)
 *         self._throw_stop("Advancing cursor", rc)             # <<<<<<<<<<<<<<
 * 
 *     property key:
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_throw_stop(__pyx_v_self, __pyx_k_36, __pyx_v_rc, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lmdb.Cursor._cursor_get", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_7_cursor_get(PyObject *__pyx_v_self, PyObject *__pyx_arg_op); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_7_cursor_get(PyObject *__pyx_v_self, PyObject *__pyx_arg_op) {
  MDB_cursor_op __pyx_v_op;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_cursor_get (wrapper)", 0);
  assert(__pyx_arg_op); {
    __pyx_v_op = ((MDB_cursor_op)PyInt_AsLong(__pyx_arg_op)); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("lmdb.Cursor._cursor_get", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_4lmdb_6Cursor_6_cursor_get(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self), ((MDB_cursor_op)__pyx_v_op));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":591
 *         _throw(what, rc)
 * 
 *     cpdef _cursor_get(self, MDB_cursor_op op):             # <<<<<<<<<<<<<<
 *         self.db._throw()
 *         rc = mdb_cursor_get(self.cursor_, &self.key_, &self.val_, op)
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_6_cursor_get(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, MDB_cursor_op __pyx_v_op) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_cursor_get", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_cursor_get(__pyx_v_self, __pyx_v_op, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor._cursor_get", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_3key_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_3key_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_3key___get__(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":598
 *     property key:
 *         """The current key. Raises an exception if the cursor is invalid."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.db._throw()
 *             return <bytes> (<char *>self.key_.mv_data)[:self.key_.mv_size]
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_3key___get__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "lmdb.pyx":599
 *         """The current key. Raises an exception if the cursor is invalid."""
 *         def __get__(self):
 *             self.db._throw()             # <<<<<<<<<<<<<<
 *             return <bytes> (<char *>self.key_.mv_data)[:self.key_.mv_size]
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->db->__pyx_vtab)->_throw(__pyx_v_self->db); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 599; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":600
 *         def __get__(self):
 *             self.db._throw()
 *             return <bytes> (<char *>self.key_.mv_data)[:self.key_.mv_size]             # <<<<<<<<<<<<<<
 * 
 *     property value:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyBytes_FromStringAndSize(((const char*)((char *)__pyx_v_self->key_.mv_data)) + 0, __pyx_v_self->key_.mv_size - 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(((PyObject *)((PyObject*)__pyx_t_1)));
  __pyx_r = ((PyObject *)__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.key.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_5value_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_5value_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_5value___get__(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":605
 *         """Returns the current value. Raises an exception if the cursor is
 *         invalid."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.db._throw()
 *             return <bytes> (<char *>self.val_.mv_data)[:self.val_.mv_size]
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_5value___get__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "lmdb.pyx":606
 *         invalid."""
 *         def __get__(self):
 *             self.db._throw()             # <<<<<<<<<<<<<<
 *             return <bytes> (<char *>self.val_.mv_data)[:self.val_.mv_size]
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->db->__pyx_vtab)->_throw(__pyx_v_self->db); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":607
 *         def __get__(self):
 *             self.db._throw()
 *             return <bytes> (<char *>self.val_.mv_data)[:self.val_.mv_size]             # <<<<<<<<<<<<<<
 * 
 *     cpdef _itervalue(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyBytes_FromStringAndSize(((const char*)((char *)__pyx_v_self->val_.mv_data)) + 0, __pyx_v_self->val_.mv_size - 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(((PyObject *)((PyObject*)__pyx_t_1)));
  __pyx_r = ((PyObject *)__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.value.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":609
 *             return <bytes> (<char *>self.val_.mv_data)[:self.val_.mv_size]
 * 
 *     cpdef _itervalue(self):             # <<<<<<<<<<<<<<
 *         # Ordered such that keys=False,values=False still returns key anyway.
 *         if self.do_values_:
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_9_itervalue(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor__itervalue(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_itervalue", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s___itervalue); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_9_itervalue)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":611
 *     cpdef _itervalue(self):
 *         # Ordered such that keys=False,values=False still returns key anyway.
 *         if self.do_values_:             # <<<<<<<<<<<<<<
 *             if self.do_keys_:
 *                 return self.key, self.value
 */
  if (__pyx_v_self->do_values_) {

    /* "lmdb.pyx":612
 *         # Ordered such that keys=False,values=False still returns key anyway.
 *         if self.do_values_:
 *             if self.do_keys_:             # <<<<<<<<<<<<<<
 *                 return self.key, self.value
 *             return self.value
 */
    if (__pyx_v_self->do_keys_) {

      /* "lmdb.pyx":613
 *         if self.do_values_:
 *             if self.do_keys_:
 *                 return self.key, self.value             # <<<<<<<<<<<<<<
 *             return self.value
 *         else:
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__key); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__value); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_1 = 0;
      __pyx_t_2 = 0;
      __pyx_r = ((PyObject *)__pyx_t_3);
      __pyx_t_3 = 0;
      goto __pyx_L0;
      goto __pyx_L4;
    }
    __pyx_L4:;

    /* "lmdb.pyx":614
 *             if self.do_keys_:
 *                 return self.key, self.value
 *             return self.value             # <<<<<<<<<<<<<<
 *         else:
 *             return self.key
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__value); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "lmdb.pyx":616
 *             return self.value
 *         else:
 *             return self.key             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__key); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }
  __pyx_L3:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lmdb.Cursor._itervalue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_9_itervalue(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_9_itervalue(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_itervalue (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_8_itervalue(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":609
 *             return <bytes> (<char *>self.val_.mv_data)[:self.val_.mv_size]
 * 
 *     cpdef _itervalue(self):             # <<<<<<<<<<<<<<
 *         # Ordered such that keys=False,values=False still returns key anyway.
 *         if self.do_values_:
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_8_itervalue(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_itervalue", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_itervalue(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor._itervalue", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_11__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_11__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_10__iter__(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":618
 *             return self.key
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_10__iter__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__", 0);

  /* "lmdb.pyx":619
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     cpdef first(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":621
 *         return self
 * 
 *     cpdef first(self):             # <<<<<<<<<<<<<<
 *         """first()
 * 
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_13first(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor_first(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("first", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__first); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_13first)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":625
 * 
 *         Reposition the cursor on the first element in the database."""
 *         self._cursor_get(MDB_FIRST)             # <<<<<<<<<<<<<<
 *         return self._itervalue()
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_cursor_get(__pyx_v_self, MDB_FIRST, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":626
 *         Reposition the cursor on the first element in the database."""
 *         self._cursor_get(MDB_FIRST)
 *         return self._itervalue()             # <<<<<<<<<<<<<<
 * 
 *     cpdef last(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_itervalue(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Cursor.first", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_13first(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_6Cursor_12first[] = "first()\n        \n        Reposition the cursor on the first element in the database.";
static PyObject *__pyx_pw_4lmdb_6Cursor_13first(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("first (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_12first(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":621
 *         return self
 * 
 *     cpdef first(self):             # <<<<<<<<<<<<<<
 *         """first()
 * 
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_12first(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("first", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->first(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.first", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":628
 *         return self._itervalue()
 * 
 *     cpdef last(self):             # <<<<<<<<<<<<<<
 *         """last()
 * 
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_15last(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor_last(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("last", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__last); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_15last)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":632
 * 
 *         Reposition the cursor on the last element in the database."""
 *         self._cursor_get(MDB_LAST)             # <<<<<<<<<<<<<<
 *         return self._itervalue()
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_cursor_get(__pyx_v_self, MDB_LAST, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":633
 *         Reposition the cursor on the last element in the database."""
 *         self._cursor_get(MDB_LAST)
 *         return self._itervalue()             # <<<<<<<<<<<<<<
 * 
 *     cpdef prev(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_itervalue(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Cursor.last", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_15last(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_6Cursor_14last[] = "last()\n        \n        Reposition the cursor on the last element in the database.";
static PyObject *__pyx_pw_4lmdb_6Cursor_15last(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("last (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_14last(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":628
 *         return self._itervalue()
 * 
 *     cpdef last(self):             # <<<<<<<<<<<<<<
 *         """last()
 * 
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_14last(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("last", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->last(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.last", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":635
 *         return self._itervalue()
 * 
 *     cpdef prev(self):             # <<<<<<<<<<<<<<
 *         """prev()
 * 
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_17prev(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor_prev(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("prev", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__prev); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 635; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_17prev)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 635; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":639
 * 
 *         Reposition the cursor on the previous element in the database."""
 *         self._cursor_get(MDB_PREV)             # <<<<<<<<<<<<<<
 *         return self._itervalue()
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_cursor_get(__pyx_v_self, MDB_PREV, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 639; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":640
 *         Reposition the cursor on the previous element in the database."""
 *         self._cursor_get(MDB_PREV)
 *         return self._itervalue()             # <<<<<<<<<<<<<<
 * 
 *     cpdef next(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_itervalue(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Cursor.prev", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_17prev(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_6Cursor_16prev[] = "prev()\n        \n        Reposition the cursor on the previous element in the database.";
static PyObject *__pyx_pw_4lmdb_6Cursor_17prev(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("prev (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_16prev(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":635
 *         return self._itervalue()
 * 
 *     cpdef prev(self):             # <<<<<<<<<<<<<<
 *         """prev()
 * 
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_16prev(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("prev", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->prev(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 635; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.prev", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":642
 *         return self._itervalue()
 * 
 *     cpdef next(self):             # <<<<<<<<<<<<<<
 *         """next()
 * 
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_19next(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor_next(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("next", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__next); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_19next)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":646
 * 
 *         Reposition the cursor on the next element in the database."""
 *         self._cursor_get(MDB_NEXT)             # <<<<<<<<<<<<<<
 *         return self._itervalue()
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_cursor_get(__pyx_v_self, MDB_NEXT, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 646; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":647
 *         Reposition the cursor on the next element in the database."""
 *         self._cursor_get(MDB_NEXT)
 *         return self._itervalue()             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_itervalue(__pyx_v_self, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Cursor.next", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_19next(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_6Cursor_18next[] = "next()\n        \n        Reposition the cursor on the next element in the database.";
static PyObject *__pyx_pw_4lmdb_6Cursor_19next(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("next (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_18next(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":642
 *         return self._itervalue()
 * 
 *     cpdef next(self):             # <<<<<<<<<<<<<<
 *         """next()
 * 
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_18next(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("next", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->next(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.next", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_21__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_21__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_20__next__(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":649
 *         return self._itervalue()
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         self._cursor_get(MDB_NEXT if self.key_.mv_data else MDB_FIRST)
 *         return self._itervalue()
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_20__next__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  MDB_cursor_op __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__next__", 0);

  /* "lmdb.pyx":650
 * 
 *     def __next__(self):
 *         self._cursor_get(MDB_NEXT if self.key_.mv_data else MDB_FIRST)             # <<<<<<<<<<<<<<
 *         return self._itervalue()
 * 
 */
  if ((__pyx_v_self->key_.mv_data != 0)) {
    __pyx_t_1 = MDB_NEXT;
  } else {
    __pyx_t_1 = MDB_FIRST;
  }
  __pyx_t_2 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_cursor_get(__pyx_v_self, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "lmdb.pyx":651
 *     def __next__(self):
 *         self._cursor_get(MDB_NEXT if self.key_.mv_data else MDB_FIRST)
 *         return self._itervalue()             # <<<<<<<<<<<<<<
 * 
 *     cpdef delete(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_itervalue(__pyx_v_self, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 651; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Cursor.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":653
 *         return self._itervalue()
 * 
 *     cpdef delete(self):             # <<<<<<<<<<<<<<
 *         """delete()
 * 
 */

static PyObject *__pyx_pw_4lmdb_6Cursor_23delete(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_4lmdb_6Cursor_delete(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("delete", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_self), __pyx_n_s__delete); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_4lmdb_6Cursor_23delete)) {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "lmdb.pyx":660
 *         """
 *         self._throw_stop("Deleting current key",
 *                          mdb_cursor_del(self.cursor_, 0))             # <<<<<<<<<<<<<<
 *         self._cursor_get(MDB_GET_CURRENT)
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_throw_stop(__pyx_v_self, __pyx_k_37, mdb_cursor_del(__pyx_v_self->cursor_, 0), 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":661
 *         self._throw_stop("Deleting current key",
 *                          mdb_cursor_del(self.cursor_, 0))
 *         self._cursor_get(MDB_GET_CURRENT)             # <<<<<<<<<<<<<<
 * 
 *     property count:
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->_cursor_get(__pyx_v_self, MDB_GET_CURRENT, 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lmdb.Cursor.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_23delete(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_4lmdb_6Cursor_22delete[] = "delete()\n\n        Delete the current key, and position the cursor on the next element in\n        the database, if any.\n        ";
static PyObject *__pyx_pw_4lmdb_6Cursor_23delete(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("delete (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_22delete(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":653
 *         return self._itervalue()
 * 
 *     cpdef delete(self):             # <<<<<<<<<<<<<<
 *         """delete()
 * 
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_22delete(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("delete", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Cursor *)__pyx_v_self->__pyx_vtab)->delete(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.delete", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_4lmdb_6Cursor_5count_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_4lmdb_6Cursor_5count_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_4lmdb_6Cursor_5count___get__(((struct __pyx_obj_4lmdb_Cursor *)__pyx_v_self));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "lmdb.pyx":666
 *         """Count of duplicates for the current key. Raises an exception if the
 *         cursor is invalid."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.db._throw()
 *             cdef size_t count
 */

static PyObject *__pyx_pf_4lmdb_6Cursor_5count___get__(struct __pyx_obj_4lmdb_Cursor *__pyx_v_self) {
  size_t __pyx_v_count;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__get__", 0);

  /* "lmdb.pyx":667
 *         cursor is invalid."""
 *         def __get__(self):
 *             self.db._throw()             # <<<<<<<<<<<<<<
 *             cdef size_t count
 *             _throw("Getting duplicate count",
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_4lmdb_Database *)__pyx_v_self->db->__pyx_vtab)->_throw(__pyx_v_self->db); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 667; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":670
 *             cdef size_t count
 *             _throw("Getting duplicate count",
 *                    mdb_cursor_count(self.cursor_, &count))             # <<<<<<<<<<<<<<
 *             return count
 */
  __pyx_t_1 = __pyx_f_4lmdb__throw(__pyx_k_38, mdb_cursor_count(__pyx_v_self->cursor_, (&__pyx_v_count))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":671
 *             _throw("Getting duplicate count",
 *                    mdb_cursor_count(self.cursor_, &count))
 *             return count             # <<<<<<<<<<<<<<
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_FromSize_t(__pyx_v_count); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 671; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lmdb.Cursor.count.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_tp_new_4lmdb_Environment(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  return o;
}

static void __pyx_tp_dealloc_4lmdb_Environment(PyObject *o) {
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_4lmdb_11Environment_3__dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static PyObject *__pyx_getprop_4lmdb_11Environment_path(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_4lmdb_11Environment_4path_1__get__(o);
}

static PyObject *__pyx_getprop_4lmdb_11Environment_max_readers(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_4lmdb_11Environment_11max_readers_1__get__(o);
}

static PyMethodDef __pyx_methods_4lmdb_Environment[] = {
  {__Pyx_NAMESTR("sync"), (PyCFunction)__pyx_pw_4lmdb_11Environment_5sync, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_11Environment_4sync)},
  {__Pyx_NAMESTR("stat"), (PyCFunction)__pyx_pw_4lmdb_11Environment_7stat, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_11Environment_6stat)},
  {__Pyx_NAMESTR("transaction"), (PyCFunction)__pyx_pw_4lmdb_11Environment_9transaction, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_11Environment_8transaction)},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_4lmdb_Environment[] = {
  {(char *)"path", __pyx_getprop_4lmdb_11Environment_path, 0, __Pyx_DOCSTR(__pyx_k_39), 0},
  {(char *)"max_readers", __pyx_getprop_4lmdb_11Environment_max_readers, 0, __Pyx_DOCSTR(__pyx_k_40), 0},
  {0, 0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_Environment = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_Environment = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_Environment = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_Environment = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

static PyTypeObject __pyx_type_4lmdb_Environment = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("lmdb.Environment"), /*tp_name*/
  sizeof(struct __pyx_obj_4lmdb_Environment), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_4lmdb_Environment, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  &__pyx_tp_as_number_Environment, /*tp_as_number*/
  &__pyx_tp_as_sequence_Environment, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_Environment, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_Environment, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  __Pyx_DOCSTR("\n    Structure for a database environment.\n\n    A DB environment supports multiple databases, all residing in the same\n    shared-memory map.\n    "), /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_4lmdb_Environment, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_4lmdb_Environment, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_4lmdb_11Environment_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_4lmdb_Environment, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  #if PY_VERSION_HEX >= 0x02060000
  0, /*tp_version_tag*/
  #endif
};
static struct __pyx_vtabstruct_4lmdb_Transaction __pyx_vtable_4lmdb_Transaction;

static PyObject *__pyx_tp_new_4lmdb_Transaction(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_4lmdb_Transaction *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_4lmdb_Transaction *)o);
  p->__pyx_vtab = __pyx_vtabptr_4lmdb_Transaction;
  p->env = ((struct __pyx_obj_4lmdb_Environment *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_4lmdb_Transaction(PyObject *o) {
  struct __pyx_obj_4lmdb_Transaction *p = (struct __pyx_obj_4lmdb_Transaction *)o;
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_4lmdb_11Transaction_3__dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->env);
  PyObject_GC_Track(o);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_4lmdb_Transaction(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_4lmdb_Transaction *p = (struct __pyx_obj_4lmdb_Transaction *)o;
  if (p->env) {
    e = (*v)(((PyObject*)p->env), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_4lmdb_Transaction(PyObject *o) {
  struct __pyx_obj_4lmdb_Transaction *p = (struct __pyx_obj_4lmdb_Transaction *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->env);
  p->env = ((struct __pyx_obj_4lmdb_Environment *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_4lmdb_Transaction[] = {
  {__Pyx_NAMESTR("db"), (PyCFunction)__pyx_pw_4lmdb_11Transaction_5db, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_11Transaction_4db)},
  {__Pyx_NAMESTR("commit"), (PyCFunction)__pyx_pw_4lmdb_11Transaction_7commit, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_11Transaction_6commit)},
  {__Pyx_NAMESTR("abort"), (PyCFunction)__pyx_pw_4lmdb_11Transaction_9abort, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_11Transaction_8abort)},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_Transaction = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_Transaction = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_Transaction = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_Transaction = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

static PyTypeObject __pyx_type_4lmdb_Transaction = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("lmdb.Transaction"), /*tp_name*/
  sizeof(struct __pyx_obj_4lmdb_Transaction), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_4lmdb_Transaction, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  &__pyx_tp_as_number_Transaction, /*tp_as_number*/
  &__pyx_tp_as_sequence_Transaction, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_Transaction, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_Transaction, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  __Pyx_DOCSTR("\n    A transaction handle.\n\n    All database operations require a transaction handle. Transactions may be\n    read-only or read-write.\n    "), /*tp_doc*/
  __pyx_tp_traverse_4lmdb_Transaction, /*tp_traverse*/
  __pyx_tp_clear_4lmdb_Transaction, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_4lmdb_Transaction, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_4lmdb_11Transaction_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_4lmdb_Transaction, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  #if PY_VERSION_HEX >= 0x02060000
  0, /*tp_version_tag*/
  #endif
};
static struct __pyx_vtabstruct_4lmdb_Database __pyx_vtable_4lmdb_Database;

static PyObject *__pyx_tp_new_4lmdb_Database(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_4lmdb_Database *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_4lmdb_Database *)o);
  p->__pyx_vtab = __pyx_vtabptr_4lmdb_Database;
  p->txn = ((struct __pyx_obj_4lmdb_Transaction *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_4lmdb_Database(PyObject *o) {
  struct __pyx_obj_4lmdb_Database *p = (struct __pyx_obj_4lmdb_Database *)o;
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_4lmdb_8Database_3__dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->txn);
  PyObject_GC_Track(o);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_4lmdb_Database(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_4lmdb_Database *p = (struct __pyx_obj_4lmdb_Database *)o;
  if (p->txn) {
    e = (*v)(((PyObject*)p->txn), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_4lmdb_Database(PyObject *o) {
  struct __pyx_obj_4lmdb_Database *p = (struct __pyx_obj_4lmdb_Database *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->txn);
  p->txn = ((struct __pyx_obj_4lmdb_Transaction *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_4lmdb_Database[] = {
  {__Pyx_NAMESTR("drop"), (PyCFunction)__pyx_pw_4lmdb_8Database_5drop, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_8Database_4drop)},
  {__Pyx_NAMESTR("get"), (PyCFunction)__pyx_pw_4lmdb_8Database_7get, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_8Database_6get)},
  {__Pyx_NAMESTR("put"), (PyCFunction)__pyx_pw_4lmdb_8Database_9put, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_8Database_8put)},
  {__Pyx_NAMESTR("delete"), (PyCFunction)__pyx_pw_4lmdb_8Database_11delete, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_8Database_10delete)},
  {__Pyx_NAMESTR("cursor"), (PyCFunction)__pyx_pw_4lmdb_8Database_13cursor, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_4lmdb_8Database_12cursor)},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_Database = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_Database = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_Database = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_Database = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

static PyTypeObject __pyx_type_4lmdb_Database = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("lmdb.Database"), /*tp_name*/
  sizeof(struct __pyx_obj_4lmdb_Database), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_4lmdb_Database, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  &__pyx_tp_as_number_Database, /*tp_as_number*/
  &__pyx_tp_as_sequence_Database, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_Database, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_Database, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  __Pyx_DOCSTR("\n    Handle for an individual database in the DB environment.\n    "), /*tp_doc*/
  __pyx_tp_traverse_4lmdb_Database, /*tp_traverse*/
  __pyx_tp_clear_4lmdb_Database, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_4lmdb_Database, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_4lmdb_8Database_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_4lmdb_Database, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  #if PY_VERSION_HEX >= 0x02060000
  0, /*tp_version_tag*/
  #endif
};
static struct __pyx_vtabstruct_4lmdb_Cursor __pyx_vtable_4lmdb_Cursor;

static PyObject *__pyx_tp_new_4lmdb_Cursor(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_4lmdb_Cursor *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_4lmdb_Cursor *)o);
  p->__pyx_vtab = __pyx_vtabptr_4lmdb_Cursor;
  p->db = ((struct __pyx_obj_4lmdb_Database *)Py_None); Py_INCREF(Py_None);
  p->txn = ((struct __pyx_obj_4lmdb_Transaction *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_4lmdb_Cursor(PyObject *o) {
  struct __pyx_obj_4lmdb_Cursor *p = (struct __pyx_obj_4lmdb_Cursor *)o;
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_4lmdb_6Cursor_3__dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->db);
  Py_CLEAR(p->txn);
  PyObject_GC_Track(o);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_4lmdb_Cursor(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_4lmdb_Cursor *p = (struct __pyx_obj_4lmdb_Cursor *)o;
  if (p->db) {
    e = (*v)(((PyObject*)p->db), a); if (e) return e;
  }
  if (p->txn) {
    e = (*v)(((PyObject*)p->txn), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_4lmdb_Cursor(PyObject *o) {
  struct __pyx_obj_4lmdb_Cursor *p = (struct __pyx_obj_4lmdb_Cursor *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->db);
  p->db = ((struct __pyx_obj_4lmdb_Database *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->txn);
  p->txn = ((struct __pyx_obj_4lmdb_Transaction *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyObject *__pyx_getprop_4lmdb_6Cursor_key(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_4lmdb_6Cursor_3key_1__get__(o);
}

static PyObject *__pyx_getprop_4lmdb_6Cursor_value(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_4lmdb_6Cursor_5value_1__get__(o);
}

static PyObject *__pyx_getprop_4lmdb_6Cursor_count(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_4lmdb_6Cursor_5count_1__get__(o);
}

static PyMethodDef __pyx_methods_4lmdb_Cursor[] = {
  {__Pyx_NAMESTR("_throw_stop"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_5_throw_stop, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("_cursor_get"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_7_cursor_get, METH_O, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("_itervalue"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_9_itervalue, METH_NOARGS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("first"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_13first, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_6Cursor_12first)},
  {__Pyx_NAMESTR("last"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_15last, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_6Cursor_14last)},
  {__Pyx_NAMESTR("prev"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_17prev, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_6Cursor_16prev)},
  {__Pyx_NAMESTR("next"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_19next, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_6Cursor_18next)},
  {__Pyx_NAMESTR("__next__"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_21__next__, METH_NOARGS|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("delete"), (PyCFunction)__pyx_pw_4lmdb_6Cursor_23delete, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_4lmdb_6Cursor_22delete)},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_4lmdb_Cursor[] = {
  {(char *)"key", __pyx_getprop_4lmdb_6Cursor_key, 0, __Pyx_DOCSTR(__pyx_k_41), 0},
  {(char *)"value", __pyx_getprop_4lmdb_6Cursor_value, 0, __Pyx_DOCSTR(__pyx_k_42), 0},
  {(char *)"count", __pyx_getprop_4lmdb_6Cursor_count, 0, __Pyx_DOCSTR(__pyx_k_43), 0},
  {0, 0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_Cursor = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_Cursor = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_Cursor = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_Cursor = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

static PyTypeObject __pyx_type_4lmdb_Cursor = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("lmdb.Cursor"), /*tp_name*/
  sizeof(struct __pyx_obj_4lmdb_Cursor), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_4lmdb_Cursor, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  &__pyx_tp_as_number_Cursor, /*tp_as_number*/
  &__pyx_tp_as_sequence_Cursor, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_Cursor, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_Cursor, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  __Pyx_DOCSTR("\n    Structure for navigating through a database.\n\n    Cursors by default are positioned on the first element in the database.\n    "), /*tp_doc*/
  __pyx_tp_traverse_4lmdb_Cursor, /*tp_traverse*/
  __pyx_tp_clear_4lmdb_Cursor, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_4lmdb_6Cursor_11__iter__, /*tp_iter*/
  __pyx_pw_4lmdb_6Cursor_21__next__, /*tp_iternext*/
  __pyx_methods_4lmdb_Cursor, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_4lmdb_Cursor, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_4lmdb_6Cursor_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_4lmdb_Cursor, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  #if PY_VERSION_HEX >= 0x02060000
  0, /*tp_version_tag*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    __Pyx_NAMESTR("lmdb"),
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
  {&__pyx_kp_s_14, __pyx_k_14, sizeof(__pyx_k_14), 0, 0, 1, 0},
  {&__pyx_kp_s_24, __pyx_k_24, sizeof(__pyx_k_24), 0, 0, 1, 0},
  {&__pyx_kp_s_44, __pyx_k_44, sizeof(__pyx_k_44), 0, 0, 1, 0},
  {&__pyx_n_s__Error, __pyx_k__Error, sizeof(__pyx_k__Error), 0, 0, 1, 1},
  {&__pyx_n_s__Exception, __pyx_k__Exception, sizeof(__pyx_k__Exception), 0, 0, 1, 1},
  {&__pyx_n_s__StopIteration, __pyx_k__StopIteration, sizeof(__pyx_k__StopIteration), 0, 0, 1, 1},
  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
  {&__pyx_n_s___cursor_get, __pyx_k___cursor_get, sizeof(__pyx_k___cursor_get), 0, 0, 1, 1},
  {&__pyx_n_s___itervalue, __pyx_k___itervalue, sizeof(__pyx_k___itervalue), 0, 0, 1, 1},
  {&__pyx_n_s___throw_stop, __pyx_k___throw_stop, sizeof(__pyx_k___throw_stop), 0, 0, 1, 1},
  {&__pyx_n_s__append, __pyx_k__append, sizeof(__pyx_k__append), 0, 0, 1, 1},
  {&__pyx_n_s__branch_pages, __pyx_k__branch_pages, sizeof(__pyx_k__branch_pages), 0, 0, 1, 1},
  {&__pyx_n_s__create, __pyx_k__create, sizeof(__pyx_k__create), 0, 0, 1, 1},
  {&__pyx_n_s__db, __pyx_k__db, sizeof(__pyx_k__db), 0, 0, 1, 1},
  {&__pyx_n_s__default, __pyx_k__default, sizeof(__pyx_k__default), 0, 0, 1, 1},
  {&__pyx_n_s__delete, __pyx_k__delete, sizeof(__pyx_k__delete), 0, 0, 1, 1},
  {&__pyx_n_s__depth, __pyx_k__depth, sizeof(__pyx_k__depth), 0, 0, 1, 1},
  {&__pyx_n_s__dupdata, __pyx_k__dupdata, sizeof(__pyx_k__dupdata), 0, 0, 1, 1},
  {&__pyx_n_s__dupsort, __pyx_k__dupsort, sizeof(__pyx_k__dupsort), 0, 0, 1, 1},
  {&__pyx_n_s__entries, __pyx_k__entries, sizeof(__pyx_k__entries), 0, 0, 1, 1},
  {&__pyx_n_s__env, __pyx_k__env, sizeof(__pyx_k__env), 0, 0, 1, 1},
  {&__pyx_n_s__exists, __pyx_k__exists, sizeof(__pyx_k__exists), 0, 0, 1, 1},
  {&__pyx_n_s__first, __pyx_k__first, sizeof(__pyx_k__first), 0, 0, 1, 1},
  {&__pyx_n_s__force, __pyx_k__force, sizeof(__pyx_k__force), 0, 0, 1, 1},
  {&__pyx_n_s__key, __pyx_k__key, sizeof(__pyx_k__key), 0, 0, 1, 1},
  {&__pyx_n_s__keys, __pyx_k__keys, sizeof(__pyx_k__keys), 0, 0, 1, 1},
  {&__pyx_n_s__last, __pyx_k__last, sizeof(__pyx_k__last), 0, 0, 1, 1},
  {&__pyx_n_s__leaf_pages, __pyx_k__leaf_pages, sizeof(__pyx_k__leaf_pages), 0, 0, 1, 1},
  {&__pyx_n_s__lmdb, __pyx_k__lmdb, sizeof(__pyx_k__lmdb), 0, 0, 1, 1},
  {&__pyx_n_s__map_async, __pyx_k__map_async, sizeof(__pyx_k__map_async), 0, 0, 1, 1},
  {&__pyx_n_s__map_size, __pyx_k__map_size, sizeof(__pyx_k__map_size), 0, 0, 1, 1},
  {&__pyx_n_s__max_dbs, __pyx_k__max_dbs, sizeof(__pyx_k__max_dbs), 0, 0, 1, 1},
  {&__pyx_n_s__max_readers, __pyx_k__max_readers, sizeof(__pyx_k__max_readers), 0, 0, 1, 1},
  {&__pyx_n_s__metasync, __pyx_k__metasync, sizeof(__pyx_k__metasync), 0, 0, 1, 1},
  {&__pyx_n_s__mkdir, __pyx_k__mkdir, sizeof(__pyx_k__mkdir), 0, 0, 1, 1},
  {&__pyx_n_s__mode, __pyx_k__mode, sizeof(__pyx_k__mode), 0, 0, 1, 1},
  {&__pyx_n_s__name, __pyx_k__name, sizeof(__pyx_k__name), 0, 0, 1, 1},
  {&__pyx_n_s__next, __pyx_k__next, sizeof(__pyx_k__next), 0, 0, 1, 1},
  {&__pyx_n_s__os, __pyx_k__os, sizeof(__pyx_k__os), 0, 0, 1, 1},
  {&__pyx_n_s__overflow_pages, __pyx_k__overflow_pages, sizeof(__pyx_k__overflow_pages), 0, 0, 1, 1},
  {&__pyx_n_s__overwrite, __pyx_k__overwrite, sizeof(__pyx_k__overwrite), 0, 0, 1, 1},
  {&__pyx_n_s__parent, __pyx_k__parent, sizeof(__pyx_k__parent), 0, 0, 1, 1},
  {&__pyx_n_s__path, __pyx_k__path, sizeof(__pyx_k__path), 0, 0, 1, 1},
  {&__pyx_n_s__prev, __pyx_k__prev, sizeof(__pyx_k__prev), 0, 0, 1, 1},
  {&__pyx_n_s__psize, __pyx_k__psize, sizeof(__pyx_k__psize), 0, 0, 1, 1},
  {&__pyx_n_s__rc, __pyx_k__rc, sizeof(__pyx_k__rc), 0, 0, 1, 1},
  {&__pyx_n_s__readonly, __pyx_k__readonly, sizeof(__pyx_k__readonly), 0, 0, 1, 1},
  {&__pyx_n_s__reverse_key, __pyx_k__reverse_key, sizeof(__pyx_k__reverse_key), 0, 0, 1, 1},
  {&__pyx_n_s__subdir, __pyx_k__subdir, sizeof(__pyx_k__subdir), 0, 0, 1, 1},
  {&__pyx_n_s__sync, __pyx_k__sync, sizeof(__pyx_k__sync), 0, 0, 1, 1},
  {&__pyx_n_s__txn, __pyx_k__txn, sizeof(__pyx_k__txn), 0, 0, 1, 1},
  {&__pyx_n_s__value, __pyx_k__value, sizeof(__pyx_k__value), 0, 0, 1, 1},
  {&__pyx_n_s__values, __pyx_k__values, sizeof(__pyx_k__values), 0, 0, 1, 1},
  {&__pyx_n_s__warnings, __pyx_k__warnings, sizeof(__pyx_k__warnings), 0, 0, 1, 1},
  {&__pyx_n_s__what, __pyx_k__what, sizeof(__pyx_k__what), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_Exception = __Pyx_GetName(__pyx_b, __pyx_n_s__Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_StopIteration = __Pyx_GetName(__pyx_b, __pyx_n_s__StopIteration); if (!__pyx_builtin_StopIteration) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "lmdb.pyx":329
 *         """Raise an exception if this transaction is complete."""
 *         if not self.running:
 *             raise Error("transaction already aborted or committed")             # <<<<<<<<<<<<<<
 * 
 *     def __init__(self, Environment env not None, Transaction parent=None,
 */
  __pyx_k_tuple_15 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_14)); if (unlikely(!__pyx_k_tuple_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_15);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_15));

  /* "lmdb.pyx":432
 *     cdef _throw(self):
 *         if self.dropped:
 *             raise Error("database was dropped.")             # <<<<<<<<<<<<<<
 *         self.txn._throw()
 * 
 */
  __pyx_k_tuple_25 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_24)); if (unlikely(!__pyx_k_tuple_25)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_25);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_25));
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initlmdb(void); /*proto*/
PyMODINIT_FUNC initlmdb(void)
#else
PyMODINIT_FUNC PyInit_lmdb(void); /*proto*/
PyMODINIT_FUNC PyInit_lmdb(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_lmdb(void)", 0);
  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("lmdb"), __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "lmdb")) {
      if (unlikely(PyDict_SetItemString(modules, "lmdb", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_module_is_main_lmdb) {
    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_4lmdb_Environment) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&__pyx_type_4lmdb_Environment, "__init__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_4lmdb_11Environment___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_4lmdb_11Environment___init__.doc = __pyx_doc_4lmdb_11Environment___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_4lmdb_11Environment___init__;
    }
  }
  #endif
  if (__Pyx_SetAttrString(__pyx_m, "Environment", (PyObject *)&__pyx_type_4lmdb_Environment) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_4lmdb_Environment = &__pyx_type_4lmdb_Environment;
  __pyx_vtabptr_4lmdb_Transaction = &__pyx_vtable_4lmdb_Transaction;
  __pyx_vtable_4lmdb_Transaction._throw = (PyObject *(*)(struct __pyx_obj_4lmdb_Transaction *))__pyx_f_4lmdb_11Transaction__throw;
  if (PyType_Ready(&__pyx_type_4lmdb_Transaction) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&__pyx_type_4lmdb_Transaction, "__init__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_4lmdb_11Transaction___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_4lmdb_11Transaction___init__.doc = __pyx_doc_4lmdb_11Transaction___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_4lmdb_11Transaction___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_4lmdb_Transaction.tp_dict, __pyx_vtabptr_4lmdb_Transaction) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "Transaction", (PyObject *)&__pyx_type_4lmdb_Transaction) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_4lmdb_Transaction = &__pyx_type_4lmdb_Transaction;
  __pyx_vtabptr_4lmdb_Database = &__pyx_vtable_4lmdb_Database;
  __pyx_vtable_4lmdb_Database._throw = (PyObject *(*)(struct __pyx_obj_4lmdb_Database *))__pyx_f_4lmdb_8Database__throw;
  if (PyType_Ready(&__pyx_type_4lmdb_Database) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&__pyx_type_4lmdb_Database, "__init__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_4lmdb_8Database___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_4lmdb_8Database___init__.doc = __pyx_doc_4lmdb_8Database___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_4lmdb_8Database___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_4lmdb_Database.tp_dict, __pyx_vtabptr_4lmdb_Database) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "Database", (PyObject *)&__pyx_type_4lmdb_Database) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_4lmdb_Database = &__pyx_type_4lmdb_Database;
  __pyx_vtabptr_4lmdb_Cursor = &__pyx_vtable_4lmdb_Cursor;
  __pyx_vtable_4lmdb_Cursor._throw_stop = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, char const *, int, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor__throw_stop;
  __pyx_vtable_4lmdb_Cursor._cursor_get = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, MDB_cursor_op, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor__cursor_get;
  __pyx_vtable_4lmdb_Cursor._itervalue = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor__itervalue;
  __pyx_vtable_4lmdb_Cursor.first = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor_first;
  __pyx_vtable_4lmdb_Cursor.last = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor_last;
  __pyx_vtable_4lmdb_Cursor.prev = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor_prev;
  __pyx_vtable_4lmdb_Cursor.next = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor_next;
  __pyx_vtable_4lmdb_Cursor.delete = (PyObject *(*)(struct __pyx_obj_4lmdb_Cursor *, int __pyx_skip_dispatch))__pyx_f_4lmdb_6Cursor_delete;
  if (PyType_Ready(&__pyx_type_4lmdb_Cursor) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&__pyx_type_4lmdb_Cursor, "__init__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_4lmdb_6Cursor___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_4lmdb_6Cursor___init__.doc = __pyx_doc_4lmdb_6Cursor___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_4lmdb_6Cursor___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_4lmdb_Cursor.tp_dict, __pyx_vtabptr_4lmdb_Cursor) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "Cursor", (PyObject *)&__pyx_type_4lmdb_Cursor) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_4lmdb_Cursor = &__pyx_type_4lmdb_Cursor;
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "lmdb.pyx":21
 * # <http://www.openldap.org/>.
 * 
 * import os             # <<<<<<<<<<<<<<
 * import warnings
 * 
 */
  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__os), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__os, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 21; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":22
 * 
 * import os
 * import warnings             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "sys/stat.h":
 */
  __pyx_t_1 = __Pyx_Import(((PyObject *)__pyx_n_s__warnings), 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 22; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__warnings, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 22; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "lmdb.pyx":167
 * 
 * 
 * class Error(Exception):             # <<<<<<<<<<<<<<
 *     """Raised when any MDB error occurs."""
 * 
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_builtin_Exception);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_builtin_Exception);
  __Pyx_GIVEREF(__pyx_builtin_Exception);
  if (PyDict_SetItemString(((PyObject *)__pyx_t_1), "__doc__", ((PyObject *)__pyx_kp_s_44)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = __Pyx_CreateClass(((PyObject *)__pyx_t_2), ((PyObject *)__pyx_t_1), __pyx_n_s__Error, __pyx_n_s__Error, __pyx_n_s__lmdb); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__Error, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;

  /* "lmdb.pyx":185
 * 
 *     def __init__(self, const char *path, size_t map_size=10485760,
 *             subdir=True, readonly=False, metasync=True,             # <<<<<<<<<<<<<<
 *             sync=True, map_async=False, mode_t mode=0644,
 *             create=True, int max_readers=126, int max_dbs=0):
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_2 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_3 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_4 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":186
 *     def __init__(self, const char *path, size_t map_size=10485760,
 *             subdir=True, readonly=False, metasync=True,
 *             sync=True, map_async=False, mode_t mode=0644,             # <<<<<<<<<<<<<<
 *             create=True, int max_readers=126, int max_dbs=0):
 *         """
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_5 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_6 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":187
 *             subdir=True, readonly=False, metasync=True,
 *             sync=True, map_async=False, mode_t mode=0644,
 *             create=True, int max_readers=126, int max_dbs=0):             # <<<<<<<<<<<<<<
 *         """
 *         Environment(path, map_size=(64Mb), subdir=True, readonly=False,
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_7 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":265
 *             return readers
 * 
 *     def sync(self, force=False):             # <<<<<<<<<<<<<<
 *         """sync(force=False)
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_12 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":332
 * 
 *     def __init__(self, Environment env not None, Transaction parent=None,
 *             readonly=False):             # <<<<<<<<<<<<<<
 *         """Transaction(env, parent=None, readonly=False)
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_16 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":394
 *     cdef int dropped
 * 
 *     def __init__(self, Transaction txn not None, name=None, reverse_key=False,             # <<<<<<<<<<<<<<
 *             dupsort=False, create=True):
 *         """Database(txn, name=None, reverse_key=False, dupsort=False, create=True)
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_20 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":395
 * 
 *     def __init__(self, Transaction txn not None, name=None, reverse_key=False,
 *             dupsort=False, create=True):             # <<<<<<<<<<<<<<
 *         """Database(txn, name=None, reverse_key=False, dupsort=False, create=True)
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_21 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_22 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":435
 *         self.txn._throw()
 * 
 *     def drop(self, delete=True):             # <<<<<<<<<<<<<<
 *         """drop(delete=True)
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_26 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":466
 *         return <bytes> (<char *>value_val.mv_data)[:value_val.mv_size]
 * 
 *     def put(self, key, value, dupdata=False, overwrite=True, append=False):             # <<<<<<<<<<<<<<
 *         """put(key, value, dupdata=False, overwrite=True, append=False)
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_28 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_29 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_30 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":561
 *     cdef int do_values_
 * 
 *     def __init__(self, Database db not None, keys=True, values=True):             # <<<<<<<<<<<<<<
 *         """Cursor(db, keys=True, values=True)
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_33 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_k_34 = __pyx_t_1;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;

  /* "lmdb.pyx":1
 * # Copyright 2013 The Python-lmdb authors, all rights reserved.             # <<<<<<<<<<<<<<
 * #
 * # Redistribution and use in source and binary forms, with or without
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  if (__pyx_m) {
    __Pyx_AddTraceback("init lmdb", __pyx_clineno, __pyx_lineno, __pyx_filename);
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init lmdb");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* Runtime support code */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif /* CYTHON_REFNANNY */

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result) {
        if (dict != __pyx_b) {
            PyErr_Clear();
            result = PyObject_GetAttr(__pyx_b, name);
        }
        if (!result) {
            PyErr_SetObject(PyExc_NameError, name);
        }
    }
    return result;
}

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_Restore(type, value, tb);
#endif
}
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(type, value, tb);
#endif
}

#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    #if PY_VERSION_HEX < 0x02050000
    if (PyClass_Check(type)) {
    #else
    if (PyType_Check(type)) {
    #endif
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        #if PY_VERSION_HEX < 0x02050000
            if (PyInstance_Check(type)) {
                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
                Py_INCREF(type);
            }
            else {
                type = 0;
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception must be an old-style class or instance");
                goto raise_error;
            }
        #else
            type = (PyObject*) Py_TYPE(type);
            Py_INCREF(type);
            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception class must be a subclass of BaseException");
                goto raise_error;
            }
        #endif
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else /* Python 3+ */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *args;
        if (!value)
            args = PyTuple_New(0);
        else if (PyTuple_Check(value)) {
            Py_INCREF(value);
            args = value;
        }
        else
            args = PyTuple_Pack(1, value);
        if (!args)
            goto bad;
        owned_instance = PyEval_CallObject(type, args);
        Py_DECREF(args);
        if (!owned_instance)
            goto bad;
        value = owned_instance;
        if (!PyExceptionInstance_Check(value)) {
            PyErr_Format(PyExc_TypeError,
                         "calling %R should have returned an instance of "
                         "BaseException, not %R",
                         type, Py_TYPE(value));
            goto bad;
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause && cause != Py_None) {
        PyObject *fixed_cause;
        if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        }
        else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        }
        else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CPYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (!type) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (Py_TYPE(obj) == type) return 1;
    }
    else {
        if (PyObject_TypeCheck(obj, type)) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%s' has incorrect type (expected %s, got %s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import = 0;
    py_import = __Pyx_GetAttrString(__pyx_b, "__import__");
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    #if PY_VERSION_HEX >= 0x02050000
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0; /* try absolute import on failure */
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
    #else
    if (level>0) {
        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
        goto bad;
    }
    module = PyObject_CallFunctionObjArgs(py_import,
        name, global_dict, empty_dict, list, NULL);
    #endif
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

static PyObject *__Pyx_FindPy2Metaclass(PyObject *bases) {
    PyObject *metaclass;
#if PY_MAJOR_VERSION < 3
    if (PyTuple_Check(bases) && PyTuple_GET_SIZE(bases) > 0) {
        PyObject *base = PyTuple_GET_ITEM(bases, 0);
        metaclass = PyObject_GetAttrString(base, (char *)"__class__");
        if (!metaclass) {
            PyErr_Clear();
            metaclass = (PyObject*) Py_TYPE(base);
        }
    } else {
        metaclass = (PyObject *) &PyClass_Type;
    }
#else
    if (PyTuple_Check(bases) && PyTuple_GET_SIZE(bases) > 0) {
        PyObject *base = PyTuple_GET_ITEM(bases, 0);
        metaclass = (PyObject*) Py_TYPE(base);
    } else {
        metaclass = (PyObject *) &PyType_Type;
    }
#endif
    Py_INCREF(metaclass);
    return metaclass;
}

static PyObject *__Pyx_CreateClass(PyObject *bases, PyObject *dict, PyObject *name,
                                   PyObject *qualname, PyObject *modname) {
    PyObject *result;
    PyObject *metaclass;
    if (PyDict_SetItemString(dict, "__module__", modname) < 0)
        return NULL;
    if (PyDict_SetItemString(dict, "__qualname__", qualname) < 0)
        return NULL;
    metaclass = PyDict_GetItemString(dict, "__metaclass__");
    if (metaclass) {
        Py_INCREF(metaclass);
    } else {
        metaclass = __Pyx_FindPy2Metaclass(bases);
    }
    result = PyObject_CallFunctionObjArgs(metaclass, name, bases, dict, NULL);
    Py_DECREF(metaclass);
    return result;
}

static CYTHON_INLINE mode_t __Pyx_PyInt_from_py_mode_t(PyObject* x) {
    const mode_t neg_one = (mode_t)-1, const_zero = (mode_t)0;
    const int is_unsigned = const_zero < neg_one;
    if (sizeof(mode_t) == sizeof(char)) {
        if (is_unsigned)
            return (mode_t)__Pyx_PyInt_AsUnsignedChar(x);
        else
            return (mode_t)__Pyx_PyInt_AsSignedChar(x);
    } else if (sizeof(mode_t) == sizeof(short)) {
        if (is_unsigned)
            return (mode_t)__Pyx_PyInt_AsUnsignedShort(x);
        else
            return (mode_t)__Pyx_PyInt_AsSignedShort(x);
    } else if (sizeof(mode_t) == sizeof(int)) {
        if (is_unsigned)
            return (mode_t)__Pyx_PyInt_AsUnsignedInt(x);
        else
            return (mode_t)__Pyx_PyInt_AsSignedInt(x);
    } else if (sizeof(mode_t) == sizeof(long)) {
        if (is_unsigned)
            return (mode_t)__Pyx_PyInt_AsUnsignedLong(x);
        else
            return (mode_t)__Pyx_PyInt_AsSignedLong(x);
    } else if (sizeof(mode_t) == sizeof(PY_LONG_LONG)) {
        if (is_unsigned)
            return (mode_t)__Pyx_PyInt_AsUnsignedLongLong(x);
        else
            return (mode_t)__Pyx_PyInt_AsSignedLongLong(x);
    }  else {
        #if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
        PyErr_SetString(PyExc_RuntimeError,
                        "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
        #else
        mode_t val;
        PyObject *v = __Pyx_PyNumber_Int(x);
        #if PY_VERSION_HEX < 0x03000000
        if (likely(v) && !PyLong_Check(v)) {
            PyObject *tmp = v;
            v = PyNumber_Long(tmp);
            Py_DECREF(tmp);
        }
        #endif
        if (likely(v)) {
            int one = 1; int is_little = (int)*(unsigned char *)&one;
            unsigned char *bytes = (unsigned char *)&val;
            int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                          bytes, sizeof(val),
                                          is_little, !is_unsigned);
            Py_DECREF(v);
            if (likely(!ret))
                return val;
        }
        #endif
        return (mode_t)-1;
    }
}

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned char" :
                    "value too large to convert to unsigned char");
            }
            return (unsigned char)-1;
        }
        return (unsigned char)val;
    }
    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned short" :
                    "value too large to convert to unsigned short");
            }
            return (unsigned short)-1;
        }
        return (unsigned short)val;
    }
    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned int" :
                    "value too large to convert to unsigned int");
            }
            return (unsigned int)-1;
        }
        return (unsigned int)val;
    }
    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
    const char neg_one = (char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to char" :
                    "value too large to convert to char");
            }
            return (char)-1;
        }
        return (char)val;
    }
    return (char)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
    const short neg_one = (short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to short" :
                    "value too large to convert to short");
            }
            return (short)-1;
        }
        return (short)val;
    }
    return (short)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
    const signed char neg_one = (signed char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed char" :
                    "value too large to convert to signed char");
            }
            return (signed char)-1;
        }
        return (signed char)val;
    }
    return (signed char)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
    const signed short neg_one = (signed short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed short" :
                    "value too large to convert to signed short");
            }
            return (signed short)-1;
        }
        return (signed short)val;
    }
    return (signed short)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
    const signed int neg_one = (signed int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed int" :
                    "value too large to convert to signed int");
            }
            return (signed int)-1;
        }
        return (signed int)val;
    }
    return (signed int)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned long");
            return (unsigned long)-1;
        }
        return (unsigned long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned long");
                return (unsigned long)-1;
            }
            return (unsigned long)PyLong_AsUnsignedLong(x);
        } else {
            return (unsigned long)PyLong_AsLong(x);
        }
    } else {
        unsigned long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned long)-1;
        val = __Pyx_PyInt_AsUnsignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned PY_LONG_LONG");
            return (unsigned PY_LONG_LONG)-1;
        }
        return (unsigned PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned PY_LONG_LONG");
                return (unsigned PY_LONG_LONG)-1;
            }
            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        unsigned PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
    const long neg_one = (long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to long");
            return (long)-1;
        }
        return (long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to long");
                return (long)-1;
            }
            return (long)PyLong_AsUnsignedLong(x);
        } else {
            return (long)PyLong_AsLong(x);
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long)-1;
        val = __Pyx_PyInt_AsLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to PY_LONG_LONG");
            return (PY_LONG_LONG)-1;
        }
        return (PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to PY_LONG_LONG");
                return (PY_LONG_LONG)-1;
            }
            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
            return (PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
    const signed long neg_one = (signed long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed long");
            return (signed long)-1;
        }
        return (signed long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed long");
                return (signed long)-1;
            }
            return (signed long)PyLong_AsUnsignedLong(x);
        } else {
            return (signed long)PyLong_AsLong(x);
        }
    } else {
        signed long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed long)-1;
        val = __Pyx_PyInt_AsSignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed PY_LONG_LONG");
            return (signed PY_LONG_LONG)-1;
        }
        return (signed PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed PY_LONG_LONG");
                return (signed PY_LONG_LONG)-1;
            }
            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        signed PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsSignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        #if PY_VERSION_HEX < 0x02050000
        return PyErr_Warn(NULL, message);
        #else
        return PyErr_WarnEx(NULL, message, 1);
        #endif
    }
    return 0;
}

static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItemString(dict, "__pyx_vtable__", ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = (start + end) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,            /*int argcount,*/
        0,            /*int kwonlyargcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,      /*int firstlineno,*/
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_globals = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else  /* Python 3+ has unicode identifiers */
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_VERSION_HEX < 0x03000000
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_VERSION_HEX < 0x03000000
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%s__ returned non-%s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
#if PY_VERSION_HEX < 0x02050000
   if (ival <= LONG_MAX)
       return PyInt_FromLong((long)ival);
   else {
       unsigned char *bytes = (unsigned char *) &ival;
       int one = 1; int little = (int)*(unsigned char*)&one;
       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
   }
#else
   return PyInt_FromSize_t(ival);
#endif
}
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
       return (size_t)-1;
   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
       PyErr_SetString(PyExc_OverflowError,
                       "value too large to convert to size_t");
       return (size_t)-1;
   }
   return (size_t)val;
}


#endif /* Py_PYTHON_H */
